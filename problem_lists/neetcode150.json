{
    "name": "NeetCode 150",
    "categories": {
        "Arrays & Hashing": [
            {
                "id": 217,
                "title": "Contains Duplicate",
                "leetcode_url": "https://leetcode.com/problems/contains-duplicate/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/contains-duplicate"
                },
                "youtube_id": "3OamzN90k_s",
                "hints": [
                    "Think about the properties of a data structure that disallows duplicates.",
                    "What is the time complexity of adding an element to a hash set?"
                ],
                "solution": {
                    "explanation": "To solve this problem efficiently, we can use a hash set (or a set in Python). We iterate through the input array, `nums`. For each number, we check if it already exists in our hash set. If it does, we have found a duplicate and can immediately return `True`. If it does not, we add the number to the hash set and continue to the next element. If we finish iterating through the entire array without finding any duplicates, we can return `False`.",
                    "code": {
                        "python": "class Solution:\n    def containsDuplicate(self, nums: list[int]) -> bool:\n        hashset = set()\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False"
                    }
                }
            },
            {
                "id": 242,
                "title": "Valid Anagram",
                "leetcode_url": "https://leetcode.com/problems/valid-anagram/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/valid-anagram"
                },
                "youtube_id": "9UtInBqnCgA",
                "hints": [
                    "What does it mean for two strings to be anagrams of each other?",
                    "Consider using a hash map or an array to count the occurrences of each character."
                ],
                "solution": {
                    "explanation": "Two strings are anagrams if they contain the same characters with the same frequencies. A straightforward way to check this is by counting the character frequencies in both strings. We can use a hash map (or a dictionary in Python) for this. First, we check if the strings have the same length; if not, they cannot be anagrams. Then, we create two hash maps, one for each string, mapping each character to its frequency. Finally, we compare the two hash maps. If they are identical, the strings are anagrams.",
                    "code": {
                        "python": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        countS, countT = {}, {}\n        \n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT"
                    }
                }
            },
            {
                "id": 1,
                "title": "Two Sum",
                "leetcode_url": "https://leetcode.com/problems/two-sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/two-sum"
                },
                "youtube_id": "KLlXCFG5TnA",
                "hints": [
                    "Think about how you can quickly look up if a number's complement exists in the array.",
                    "A hash map is excellent for storing and retrieving values in constant time on average."
                ],
                "solution": {
                    "explanation": "We can solve this in one pass using a hash map. The hash map will store the numbers we've seen so far and their indices. We iterate through the input array `nums`. For each number `n` at index `i`, we calculate its required complement: `diff = target - n`. We then check if this `diff` already exists as a key in our hash map. If it does, it means we have found our pair, and we can return the index stored in the hash map for `diff` and the current index `i`. If `diff` is not in the map, we add the current number `n` and its index `i` to the map and continue.",
                    "code": {
                        "python": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        prevMap = {} # val -> index\n        \n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i"
                    }
                }
            },
            {
                "id": 49,
                "title": "Group Anagrams",
                "leetcode_url": "https://leetcode.com/problems/group-anagrams/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/group-anagrams"
                },
                "youtube_id": "vzdNOK2oB2E",
                "hints": [
                    "How can you generate a unique key for each group of anagrams?",
                    "Sorting a string produces a canonical representation for any set of anagrams."
                ],
                "solution": {
                    "explanation": "The key insight is that all anagrams, when their characters are sorted, will result in the exact same string. We can use this sorted string as a unique key for each group of anagrams. We initialize a hash map (dictionary in Python) where keys will be the sorted strings and values will be lists of the original strings. We iterate through the input list of strings. For each string, we create its sorted version to use as a key. We then append the original string to the list associated with this key in our hash map. Finally, the values of the hash map will be the lists of grouped anagrams.",
                    "code": {
                        "python": "from collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n        ans = defaultdict(list)\n        \n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\"a\")] += 1\n            ans[tuple(count)].append(s)\n        return list(ans.values())"
                    }
                }
            },
            {
                "id": 347,
                "title": "Top K Frequent Elements",
                "leetcode_url": "https://leetcode.com/problems/top-k-frequent-elements/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/top-k-frequent-elements"
                },
                "youtube_id": "YPTqKIgVk-k",
                "hints": [
                    "First, you need to count the frequency of each number. A hash map is perfect for this.",
                    "How can you efficiently find the top 'k' elements based on frequency? A heap is one option, but is there a way to do it in linear time?"
                ],
                "solution": {
                    "explanation": "This can be solved efficiently using a variation of Bucket Sort. First, we iterate through the input array and use a hash map to count the frequency of each number. The maximum possible frequency is the length of the array. We can then create a list of lists (our 'buckets'), where the index of the outer list represents a frequency count. We iterate through our frequency map and place each number into the bucket corresponding to its frequency. Finally, we iterate through the buckets from right to left (from highest frequency to lowest) and collect the numbers until we have `k` elements.",
                    "code": {
                        "python": "class Solution:\n    def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n        \n        for n in nums:\n            count[n] = 1 + count.get(n, 0)\n        for n, c in count.items():\n            freq[c].append(n)\n        \n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for n in freq[i]:\n                res.append(n)\n                if len(res) == k:\n                    return res"
                    }
                }
            },
            {
                "id": 238,
                "title": "Product of Array Except Self",
                "leetcode_url": "https://leetcode.com/problems/product-of-array-except-self/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/product-of-array-except-self"
                },
                "youtube_id": "bNvIQI2wAjk",
                "hints": [
                    "You are not allowed to use the division operator.",
                    "Consider calculating all the prefix products and all the postfix products first."
                ],
                "solution": {
                    "explanation": "To solve this without using division, we can make two passes through the array. First, we create an answer array. In the first pass, we iterate from left to right, and for each position `i`, we calculate the product of all elements to its left (the 'prefix product'). In the second pass, we iterate from right to left. We use a variable to keep track of the product of all elements to the right (the 'postfix product'). For each position `i`, we multiply the existing prefix product in our answer array by the current postfix product. After this second pass, each position in the answer array will hold the product of all elements except itself.",
                    "code": {
                        "python": "class Solution:\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\n        res = [1] * (len(nums))\n        \n        prefix = 1\n        for i in range(len(nums)):\n            res[i] = prefix\n            prefix *= nums[i]\n        \n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res"
                    }
                }
            },
            {
                "id": 36,
                "title": "Valid Sudoku",
                "leetcode_url": "https://leetcode.com/problems/valid-sudoku/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/valid-sudoku"
                },
                "youtube_id": "TjFXEUCMqI8",
                "hints": [
                    "You need to validate three conditions: rows, columns, and 3x3 sub-boxes.",
                    "Use a hash set to keep track of the numbers you've seen in the current row, column, or sub-box."
                ],
                "solution": {
                    "explanation": "The most direct way to solve this is to check all three conditions separately. We can use hash sets to keep track of the numbers seen in each row, column, and 3x3 sub-box. We can use three collections of hash sets: one for rows, one for columns, and one for the 3x3 boxes. We iterate through the 9x9 board. For each cell that is not empty, we check if its value is already in the hash set for its corresponding row, column, and 3x3 box. If it is, the board is invalid. If not, we add the value to all three respective hash sets. The key to identifying the 3x3 box is using integer division, e.g., `(row // 3, col // 3)`.",
                    "code": {
                        "python": "from collections import defaultdict\n\nclass Solution:\n    def isValidSudoku(self, board: list[list[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set) # key = (r//3, c//3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                \n                if (board[r][c] in rows[r] or\n                    board[r][c] in cols[c] or\n                    board[r][c] in squares[(r//3, c//3)]):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r//3, c//3)].add(board[r][c])\n        return True"
                    }
                }
            },
            {
                "id": 128,
                "title": "Longest Consecutive Sequence",
                "leetcode_url": "https://leetcode.com/problems/longest-consecutive-sequence/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-consecutive-sequence"
                },
                "youtube_id": "P6RZZMu_maU",
                "hints": [
                    "The solution needs to be O(n). Sorting would be O(n log n), so that's not ideal.",
                    "If you convert the array to a set, you can check for the existence of a number in O(1) time. How can you use this to find the start of a sequence?"
                ],
                "solution": {
                    "explanation": "To achieve a linear time solution, we first convert the input array `nums` into a hash set for O(1) lookups. We then iterate through each number `n` in our set. The crucial insight is to identify the start of a sequence. A number `n` is the start of a sequence if `n-1` is not in the hash set. When we find a start, we begin counting upwards (`n+1`, `n+2`, etc.) as long as the next number exists in our set, keeping track of the current sequence length. We update our overall longest sequence length after each sequence check. This approach is O(n) because even though there's a nested loop, each number in the set is visited at most twice.",
                    "code": {
                        "python": "class Solution:\n    def longestConsecutive(self, nums: list[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n        \n        for n in nums:\n            # check if its the start of a sequence\n            if (n-1) not in numSet:\n                length = 0\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest"
                    }
                }
            }
        ],
        "Two Pointers": [
            {
                "id": 125,
                "title": "Valid Palindrome",
                "leetcode_url": "https://leetcode.com/problems/valid-palindrome/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/valid-palindrome"
                },
                "youtube_id": "jJXJ16kPFWg",
                "hints": [
                    "Use two pointers, one at the start and one at the end of the string.",
                    "Remember to handle non-alphanumeric characters by skipping them."
                ],
                "solution": {
                    "explanation": "A common approach is to use two pointers, `l` starting at the beginning of the string and `r` at the end. We move these pointers toward the center. At each step, we must handle non-alphanumeric characters. We advance the left pointer as long as it points to a non-alphanumeric character, and we do the same for the right pointer. Once both pointers are at valid characters, we compare them (after converting to lowercase). If they are not equal, the string is not a palindrome. If they are equal, we move both pointers inward and repeat the process. If the pointers cross (`l >= r`), it means all characters have been checked, and the string is a palindrome.",
                    "code": {
                        "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not self.alphanum(s[l]):\n                l += 1\n            while l < r and not self.alphanum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n\n    def alphanum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or\n                ord('a') <= ord(c) <= ord('z') or\n                ord('0') <= ord(c) <= ord('9'))"
                    }
                }
            },
            {
                "id": 167,
                "title": "Two Sum II - Input Array Is Sorted",
                "leetcode_url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/two-sum-ii-input-array-is-sorted"
                },
                "youtube_id": "cQ1Oz4y7dGo",
                "hints": [
                    "The input array is already sorted. How can this property be exploited?",
                    "Consider starting with pointers at both ends of the array."
                ],
                "solution": {
                    "explanation": "Since the array is sorted, we can use a two-pointer approach to find the solution in O(n) time and O(1) space. We initialize a left pointer `l` at the beginning of the array and a right pointer `r` at the end. We then check the sum of the values at these two pointers. If the sum is greater than the target, we need a smaller sum, so we decrement the right pointer. If the sum is less than the target, we need a larger sum, so we increment the left pointer. If the sum is equal to the target, we have found our two numbers, and we can return their indices (plus one, as the problem asks for 1-based indexing).",
                    "code": {
                        "python": "class Solution:\n    def twoSum(self, numbers: list[int], target: int) -> list[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]"
                    }
                }
            },
            {
                "id": 15,
                "title": "3Sum",
                "leetcode_url": "https://leetcode.com/problems/3sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/3sum"
                },
                "youtube_id": "jzZfxsIWhO4",
                "hints": [
                    "To easily avoid duplicate triplets, sort the input array first.",
                    "After sorting, iterate through the array and for each element, use a two-pointer approach on the remainder of the array."
                ],
                "solution": {
                    "explanation": "To solve this problem efficiently and handle duplicates, we first sort the input array `nums`. Then, we iterate through the array with a primary pointer `i`. For each `nums[i]`, we need to find two other numbers in the array that sum up to `-nums[i]`. This subproblem is effectively 'Two Sum II'. We use two more pointers, `l` (starting at `i+1`) and `r` (starting at the end of the array), on the subarray to the right of `i`. We move `l` and `r` based on whether their sum is greater than, less than, or equal to the target (`-nums[i]`). A crucial step is to handle duplicates. We skip duplicate values for our main pointer `i`. After finding a valid triplet, we also move our `l` pointer forward as long as it points to a duplicate value to avoid including the same triplet multiple times.",
                    "code": {
                        "python": "class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if i > 0 and a == nums[i-1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"
                    }
                }
            },
            {
                "id": 11,
                "title": "Container With Most Water",
                "leetcode_url": "https://leetcode.com/problems/container-with-most-water/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/container-with-most-water"
                },
                "youtube_id": "UuiTKBwPgAo",
                "hints": [
                    "Start with the widest possible container (pointers at both ends).",
                    "To potentially increase the area, you should move the pointer that points to the shorter of the two lines."
                ],
                "solution": {
                    "explanation": "This problem can be solved in linear time using a two-pointer approach. We initialize a left pointer `l` at the beginning and a right pointer `r` at the end of the `height` array. These two pointers form the widest possible container. We calculate the area, which is `(r - l) * min(height[l], height[r])`, and keep track of the maximum area found so far. The key insight is how to move the pointers. The area is always limited by the shorter of the two lines. If we move the pointer of the taller line, the width decreases, and the height is still limited by the shorter line, guaranteeing that the new area will be smaller. Therefore, to have any chance of finding a larger area, we must move the pointer of the shorter line inward. We repeat this process until `l` and `r` cross.",
                    "code": {
                        "python": "class Solution:\n    def maxArea(self, height: list[int]) -> int:\n        l, r = 0, len(height) - 1\n        res = 0\n\n        while l < r:\n            area = (r - l) * min(height[l], height[r])\n            res = max(res, area)\n\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n        return res"
                    }
                }
            },
            {
                "id": 42,
                "title": "Trapping Rain Water",
                "leetcode_url": "https://leetcode.com/problems/trapping-rain-water/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/trapping-rain-water"
                },
                "youtube_id": "ZI2z5pq0TqA",
                "hints": [
                    "The amount of water trapped above any given bar is `min(max_left_height, max_right_height) - current_height`.",
                    "Consider a two-pointer approach where you maintain the maximum height seen so far from both the left and right ends."
                ],
                "solution": {
                    "explanation": "An optimal solution uses a two-pointer approach in O(n) time and O(1) space. We initialize a left pointer `l` at the start, a right pointer `r` at the end, and two variables `leftMax` and `rightMax` to store the max height encountered from each side. At each step, we check if `leftMax` is less than `rightMax`. If it is, it means the trapping water level on the left side is bounded by `leftMax`. We can then calculate the water trapped at `l` as `leftMax - height[l]` (if positive) and add it to our total. Then, we move `l` one step to the right. If `rightMax` is less than or equal to `leftMax`, we do the same logic for the right pointer `r`. This works because we are always processing the pointer with the smaller max boundary, which guarantees that the water level calculation is correct.",
                    "code": {
                        "python": "class Solution:\n    def trap(self, height: list[int]) -> int:\n        if not height: return 0\n        \n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res"
                    }
                }
            }
        ],
        "Sliding Window": [
            {
                "id": 121,
                "title": "Best Time to Buy and Sell Stock",
                "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/best-time-to-buy-and-sell-stock"
                },
                "youtube_id": "1pkOgXD63yU",
                "hints": [
                    "Think of this as finding the maximum difference between two numbers in the array, with the constraint that the smaller number must come before the larger one.",
                    "You can use a two-pointer or 'sliding window' approach. One pointer tracks the lowest buy price found so far, and the other iterates through the days to find the best sell price."
                ],
                "solution": {
                    "explanation": "This problem can be solved efficiently in a single pass using a sliding window approach. We use two pointers, `l` (for buy) and `r` (for sell). We initialize the `l` pointer at the start and iterate the `r` pointer from the second day onwards. At each step, we check if the current sell price `prices[r]` is lower than our current buy price `prices[l]`. If it is, it means we've found a new, better day to buy, so we update our buy pointer `l` to the current position `r`. If the sell price is higher, we have a potential profit. We calculate this profit (`prices[r] - prices[l]`) and update our overall maximum profit found so far. We continue this until the `r` pointer has traversed the entire array.",
                    "code": {
                        "python": "class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        l, r = 0, 1 # l=buy, r=sell\n        maxP = 0\n\n        while r < len(prices):\n            # profitable?\n            if prices[l] < prices[r]:\n                profit = prices[r] - prices[l]\n                maxP = max(maxP, profit)\n            else:\n                l = r\n            r += 1\n        return maxP"
                    }
                }
            },
            {
                "id": 3,
                "title": "Longest Substring Without Repeating Characters",
                "leetcode_url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-substring-without-repeating-characters"
                },
                "youtube_id": "wiGpQwVHdE0",
                "hints": [
                    "Use a sliding window represented by two pointers.",
                    "A hash set can be used to efficiently track the characters currently inside your sliding window."
                ],
                "solution": {
                    "explanation": "We can solve this using a sliding window approach with two pointers, `l` and `r`, that define the boundaries of our current substring. We also use a hash set to store the characters currently in our window. We expand the window by moving the right pointer `r`. At each step, we check if the character `s[r]` is already in our hash set. If it is, it means we have a repeating character. To fix this, we must shrink our window from the left by removing `s[l]` from the set and incrementing the `l` pointer. We repeat this shrinking process until the character `s[r]` is no longer a duplicate in the set. Once it's not a duplicate, we can add `s[r]` to the set and update our result with the new maximum window size (`r - l + 1`).",
                    "code": {
                        "python": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res"
                    }
                }
            },
            {
                "id": 424,
                "title": "Longest Repeating Character Replacement",
                "leetcode_url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-repeating-character-replacement"
                },
                "youtube_id": "gqXU1UyA8pk",
                "hints": [
                    "The key condition to check for a valid window is: `window_length - count_of_most_frequent_character <= k`.",
                    "Use a sliding window and a hash map to keep track of character frequencies within that window."
                ],
                "solution": {
                    "explanation": "This is a sliding window problem. We maintain a window and a hash map to count the frequencies of characters within it. The key condition for a valid window is `(r - l + 1) - maxf <= k`, where `(r - l + 1)` is the window length and `maxf` is the frequency of the most common character in that window. This formula tells us the number of characters we need to replace. We expand the window by moving the right pointer `r` and updating the frequency count for `s[r]`. We also keep track of the max frequency (`maxf`) seen so far. If our condition is violated (we need more replacements than `k` allows), we shrink the window from the left by decrementing the count for `s[l]` and moving the `l` pointer. Throughout this process, we keep track of the maximum valid window length found.",
                    "code": {
                        "python": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        res = 0\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n            \n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n            \n            res = max(res, r - l + 1)\n        return res"
                    }
                }
            },
            {
                "id": 76,
                "title": "Minimum Window Substring",
                "leetcode_url": "https://leetcode.com/problems/minimum-window-substring/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/minimum-window-substring"
                },
                "youtube_id": "jSto0O4AJbM",
                "hints": [
                    "Use a sliding window approach. You need two hash maps: one to store the character counts of the target string `t`, and another to track the character counts in your current window.",
                    "Keep track of how many characters from `t` you have in your window and how many you need. Expand the window until it's valid, then shrink it from the left to find the minimum possible size."
                ],
                "solution": {
                    "explanation": "We use a sliding window approach with two hash maps. The first map, `countT`, stores the character frequencies required by string `t`. The second, `window`, stores the frequencies in our current window. We also use two counters, `have` and `need`. `need` is the number of unique characters in `t`, and `have` tracks how many of those unique characters we have met the frequency requirement for in our current window. We expand the window by moving the right pointer `r`. Whenever a character's count in `window` matches its count in `countT`, we increment `have`. Once `have == need`, our window is valid. We then try to shrink it from the left by moving the `l` pointer. As we shrink, if a character's count drops below what's required, we decrement `have`, and the window becomes invalid again. We continue this process, keeping track of the smallest valid window found.",
                    "code": {
                        "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\": return \"\"\n        \n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n            \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            \n            if c in countT and window[c] == countT[c]:\n                have += 1\n            \n            while have == need:\n                # update our result\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = (r - l + 1)\n                # pop from the left of our window\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float(\"infinity\") else \"\""
                    }
                }
            },
            {
                "id": 567,
                "title": "Permutation in String",
                "leetcode_url": "https://leetcode.com/problems/permutation-in-string/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/permutation-in-string"
                },
                "youtube_id": "UbyhOgBN834",
                "hints": [
                    "How do you check if one string is a permutation of another? By comparing their character frequency maps.",
                    "Use a fixed-size sliding window with a length equal to the length of `s1`. Slide this window across `s2` and check if the character counts inside the window match the counts for `s1`."
                ],
                "solution": {
                    "explanation": "This problem asks if any permutation of `s1` is a substring of `s2`. This is equivalent to finding a substring in `s2` that has the exact same character counts as `s1`. We can use a fixed-size sliding window. First, we compute the character frequency map of `s1`. Then, we slide a window of size `len(s1)` across `s2`. For each window, we compute its character frequency map and compare it to the map of `s1`. If they match, we return `True`. To optimize, instead of re-computing the map for each window, we can slide the window one character at a time, updating the frequency map by decrementing the count of the character leaving the window and incrementing the count of the character entering it.",
                    "code": {
                        "python": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2): return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord('a')] += 1\n            s2Count[ord(s2[i]) - ord('a')] += 1\n\n        matches = 0\n        for i in range(26):\n            if s1Count[i] == s2Count[i]:\n                matches += 1\n        \n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26: return True\n\n            index = ord(s2[r]) - ord('a')\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n            \n            index = ord(s2[l]) - ord('a')\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26"
                    }
                }
            },
            {
                "id": 239,
                "title": "Sliding Window Maximum",
                "leetcode_url": "https://leetcode.com/problems/sliding-window-maximum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/sliding-window-maximum"
                },
                "youtube_id": "DfljaUwZsOk",
                "hints": [
                    "A brute-force approach would be O(n*k). We need something faster.",
                    "Consider a data structure that can efficiently add elements to one end and remove elements from both ends, while keeping track of the maximum. A double-ended queue (deque) is perfect for this."
                ],
                "solution": {
                    "explanation": "To solve this in linear time, we use a sliding window along with a deque (double-ended queue). The deque will store the indices of elements in the current window. Crucially, we maintain the indices in the deque in decreasing order of their corresponding values in the input array. As we slide our window to the right, for each new element, we first pop any indices from the right end of the deque that correspond to values smaller than the new element. This maintains the decreasing order property. After that, we add the new element's index to the right of the deque. We also check the left end of the deque to remove any indices that have fallen out of the current window's bounds. At each step, the index at the very front (left) of the deque always corresponds to the maximum element in the current window.",
                    "code": {
                        "python": "import collections\n\nclass Solution:\n    def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n        output = []\n        q = collections.deque()  # index\n        l = r = 0\n        # O(n) O(n)\n        while r < len(nums):\n            # pop smaller values from q\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            # remove left val from window\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output"
                    }
                }
            }
        ],
        "Stack": [
            {
                "id": 20,
                "title": "Valid Parentheses",
                "leetcode_url": "https://leetcode.com/problems/valid-parentheses/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/valid-parentheses"
                },
                "youtube_id": "WTzjTskfRnM",
                "hints": [
                    "A stack is the perfect data structure for this problem.",
                    "When you encounter an opening bracket, push it onto the stack. When you see a closing bracket, check if the top of the stack is the matching opening bracket."
                ],
                "solution": {
                    "explanation": "This problem is a classic use case for a stack. We iterate through the input string. If we encounter an opening bracket ('(', '{', '['), we push it onto the stack. If we encounter a closing bracket, we check two conditions: first, if the stack is empty, it means we have a closing bracket without a corresponding opener, so we return `False`. Second, we pop the top element from the stack and check if it's the matching opening bracket for the current closing bracket. If it's not a match, we return `False`. After iterating through the entire string, if the stack is empty, it means every opening bracket had a matching closing bracket in the correct order, so we return `True`. If the stack is not empty, it means we have unclosed opening brackets, so we return `False`.",
                    "code": {
                        "python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        closeToOpen = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }\n\n        for c in s:\n            if c in closeToOpen:\n                if stack and stack[-1] == closeToOpen[c]:\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(c)\n        \n        return True if not stack else False"
                    }
                }
            },
            {
                "id": 155,
                "title": "Min Stack",
                "leetcode_url": "https://leetcode.com/problems/min-stack/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/min-stack"
                },
                "youtube_id": "vB-81TB6X-4",
                "hints": [
                    "The challenge is to retrieve the minimum element in O(1) time.",
                    "Consider using an auxiliary stack that only stores the minimum values found so far."
                ],
                "solution": {
                    "explanation": "To achieve O(1) time complexity for `getMin`, we can use two stacks. The main stack will behave like a normal stack. The second stack, `minStack`, will store the minimum values. When we push a value `val` onto the main stack, we also push a value onto `minStack`. The value pushed to `minStack` is `val` if it's less than or equal to the current minimum (the top of `minStack`), otherwise, we push the current minimum again. When we pop from the main stack, we also pop from `minStack`. This ensures that the top of `minStack` always holds the minimum value of all elements currently in the main stack. `getMin` simply returns the top of `minStack`.",
                    "code": {
                        "python": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]"
                    }
                }
            },
            {
                "id": 150,
                "title": "Evaluate Reverse Polish Notation",
                "leetcode_url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/evaluate-reverse-polish-notation"
                },
                "youtube_id": "iu00C2cKGAI",
                "hints": [
                    "Reverse Polish Notation is evaluated using a stack.",
                    "When you see a number, push it onto the stack. When you see an operator, pop the top two numbers, perform the operation, and push the result back onto the stack."
                ],
                "solution": {
                    "explanation": "This problem is perfectly suited for a stack. We iterate through the list of `tokens`. If a token is a number, we convert it to an integer and push it onto the stack. If the token is an operator ('+', '-', '*', '/'), we pop the top two elements from the stack (let's call them `a` and `b`, where `b` was pushed before `a`). We then perform the operation (`b` operator `a`) and push the result back onto the stack. It's important to get the order right for subtraction and division. After iterating through all tokens, the final result will be the only element left on the stack.",
                    "code": {
                        "python": "class Solution:\n    def evalRPN(self, tokens: list[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(b / a))\n            else:\n                stack.append(int(c))\n        return stack[0]"
                    }
                }
            },
            {
                "id": 22,
                "title": "Generate Parentheses",
                "leetcode_url": "https://leetcode.com/problems/generate-parentheses/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/generate-parentheses"
                },
                "youtube_id": "s9fokUqJ76A",
                "hints": [
                    "This is a backtracking problem.",
                    "Think about the conditions for a valid sequence of parentheses. At any point, the number of closing brackets cannot exceed the number of opening brackets. And you can only use `n` of each."
                ],
                "solution": {
                    "explanation": "We can solve this using backtracking. We build the string recursively, keeping track of the number of open parentheses (`openN`) and closed parentheses (`closeN`) used. Our recursive function has two main base cases. The primary base case is when `openN == closeN == n`, which means we have formed a complete and valid combination, so we add it to our result list. The recursive steps involve two choices: 1. We can add an opening parenthesis if `openN < n`. 2. We can add a closing parenthesis if `closeN < openN`. This second condition is crucial as it ensures we never add a closing bracket without a corresponding open one. We start the recursion from an empty string with `openN = 0` and `closeN = 0`.",
                    "code": {
                        "python": "class Solution:\n    def generateParenthesis(self, n: int) -> list[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res"
                    }
                }
            },
            {
                "id": 739,
                "title": "Daily Temperatures",
                "leetcode_url": "https://leetcode.com/problems/daily-temperatures/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/daily-temperatures"
                },
                "youtube_id": "cTgkbbAhV74",
                "hints": [
                    "A monotonic decreasing stack can be used here.",
                    "Iterate through the temperatures. If the current temperature is greater than the temperature at the index on top of the stack, you've found the answer for that day. Pop it, calculate the difference in days, and repeat."
                ],
                "solution": {
                    "explanation": "An efficient solution uses a monotonic decreasing stack. The stack will store pairs of `[temperature, index]`. We iterate through the input `temperatures` array. For each temperature, we check the top of the stack. As long as the stack is not empty and the current temperature is greater than the temperature at the top of the stack, we have found the answer for the day corresponding to the stack's top element. We pop from the stack, calculate the day difference (`current_index - popped_index`), and store it in our result array at the `popped_index`. We repeat this until the stack is empty or the current temperature is no longer greater than the top. Then, we push the current temperature and its index onto the stack. This ensures the stack always maintains a monotonically decreasing order of temperatures.",
                    "code": {
                        "python": "class Solution:\n    def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n        res = [0] * len(temperatures)\n        stack = [] # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = (i - stackInd)\n            stack.append([t, i])\n        return res"
                    }
                }
            },
            {
                "id": 853,
                "title": "Car Fleet",
                "leetcode_url": "https://leetcode.com/problems/car-fleet/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/car-fleet"
                },
                "youtube_id": "PrGgVbviGVE",
                "hints": [
                    "Think about the problem from the perspective of the cars closest to the target.",
                    "Sort the cars based on their starting positions. Then, iterate backwards from the car closest to the target, calculating the time each car takes to reach the target."
                ],
                "solution": {
                    "explanation": "The key is to consider the cars from closest to the target to furthest. We first combine the `position` and `speed` arrays into pairs and sort them based on position in descending order. Now we are processing cars from right to left. We use a stack to keep track of the arrival times of the fleets. We iterate through our sorted cars. For each car, we calculate the time it will take to reach the target: `time = (target - position) / speed`. We then look at the top of the stack, which represents the arrival time of the fleet immediately ahead. If the current car's arrival time is less than or equal to the time of the fleet ahead, it means this car will catch up and become part of that fleet, so we do nothing. If its arrival time is greater, it means it's slower and will form a new fleet. In this case, we push its arrival time onto the stack. The final answer is the size of the stack.",
                    "code": {
                        "python": "class Solution:\n    def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:\n        pair = [[p, s] for p, s in zip(position, speed)]\n        stack = []\n\n        for p, s in sorted(pair)[::-1]: # Reverse sorted order\n            stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)"
                    }
                }
            },
            {
                "id": 84,
                "title": "Largest Rectangle in Histogram",
                "leetcode_url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/largest-rectangle-in-histogram"
                },
                "youtube_id": "zx5Sw9130L0",
                "hints": [
                    "For each bar, if we knew the index of the first smaller bar to its left and the first smaller bar to its right, we could calculate the maximum area for a rectangle using that bar as the height.",
                    "A monotonic increasing stack can be used to efficiently find the next smaller element for each bar."
                ],
                "solution": {
                    "explanation": "This problem can be solved efficiently using a monotonic increasing stack. The stack will store pairs of `[index, height]`. We iterate through the `heights` array. For each bar, if the stack is empty or the current bar's height is greater than the height at the top of the stack, we push its index and height. If the current bar is shorter, it means we have found the 'next smaller element' for the bar(s) on the stack. We pop from the stack and calculate the area for the popped bar. The height is the popped bar's height, and the width is `current_index - popped_bar_start_index`. We repeat this until the stack is empty or the top is smaller than the current bar. A key detail is handling the end of the array. After the loop finishes, we must process any remaining elements on the stack, calculating their areas as if the 'next smaller element' is at the very end of the array.",
                    "code": {
                        "python": "class Solution:\n    def largestRectangleArea(self, heights: list[int]) -> int:\n        maxArea = 0\n        stack = [] # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea"
                    }
                }
            }
        ],
        "Binary Search": [
            {
                "id": 704,
                "title": "Binary Search",
                "leetcode_url": "https://leetcode.com/problems/binary-search/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/binary-search"
                },
                "youtube_id": "s4DPM8ct1pI",
                "hints": [
                    "The core idea is to repeatedly divide the search interval in half.",
                    "Maintain left and right pointers. The middle element is compared with the target to determine if you should search the left or right half next."
                ],
                "solution": {
                    "explanation": "Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. We begin with an interval covering the whole array, defined by a left pointer and a right pointer. We then compare the target value with the value of the middle element. If the target value matches the middle element, we have found our item. If the target value is less than the middle element, we narrow our interval to the lower half. Otherwise, we narrow it to the upper half. We repeat this process until the value is found or the interval is empty.",
                    "code": {
                        "python": "class Solution:\n    def search(self, nums: list[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1"
                    }
                }
            },
            {
                "id": 74,
                "title": "Search a 2D Matrix",
                "leetcode_url": "https://leetcode.com/problems/search-a-2d-matrix/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/search-a-2d-matrix"
                },
                "youtube_id": "Ber2pi2C0j0",
                "hints": [
                    "The matrix can be conceptually flattened into a single sorted 1D array.",
                    "You can perform a binary search. A given 1D index `mid` can be converted to 2D coordinates `(row, col)` using division and modulus."
                ],
                "solution": {
                    "explanation": "Although the input is a 2D matrix, the properties given (rows are sorted, and the first element of a row is greater than the last of the previous row) mean it's essentially a flattened, sorted 1D array. We can apply binary search directly. We can treat the matrix as a 1D array of size `rows * cols` and use left and right pointers. For any given middle index `mid` in our 1D view, the corresponding element in the 2D matrix is at `matrix[mid // cols][mid % cols]`. We compare this element with the target and adjust our left and right pointers just like in a standard binary search.",
                    "code": {
                        "python": "class Solution:\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n        \n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False"
                    }
                }
            },
            {
                "id": 875,
                "title": "Koko Eating Bananas",
                "leetcode_url": "https://leetcode.com/problems/koko-eating-bananas/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/koko-eating-bananas"
                },
                "youtube_id": "U2SozAs9RzA",
                "hints": [
                    "The possible eating speed `k` can range from 1 to the maximum number of bananas in any single pile.",
                    "This range of possible answers suggests we can use binary search on the eating speed `k` to find the minimum valid speed."
                ],
                "solution": {
                    "explanation": "This problem asks for the minimum integer `k` (eating speed) such that Koko can eat all bananas within `h` hours. This is a classic 'binary search on the answer' problem. The search space for the speed `k` is from 1 to `max(piles)`. We perform a binary search within this range. For a given middle speed `k`, we have a helper function that calculates the total hours required to eat all bananas at that speed. If the calculated hours are less than or equal to the given `h`, it means this speed `k` is a possible answer, and we try to find an even smaller valid speed by searching in the left half. If the hours are more than `h`, the speed is too slow, and we must search in the right half for a higher speed. We keep track of the minimum valid speed found.",
                    "code": {
                        "python": "import math\n\nclass Solution:\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n            hours = 0\n            for p in piles:\n                hours += math.ceil(p / k)\n            \n            if hours <= h:\n                res = min(res, k)\n                r = k - 1\n            else:\n                l = k + 1\n        return res"
                    }
                }
            },
            {
                "id": 153,
                "title": "Find Minimum in Rotated Sorted Array",
                "leetcode_url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/find-minimum-in-rotated-sorted-array"
                },
                "youtube_id": "nIVW4P8b1VA",
                "hints": [
                    "The array has a pivot point. All numbers to the left of the pivot are greater than all numbers to the right.",
                    "Use a modified binary search. Compare the middle element with the rightmost element. This comparison tells you which side of the middle element the pivot (and thus the minimum value) is on."
                ],
                "solution": {
                    "explanation": "We can find the minimum element using a modified binary search. We initialize left and right pointers. At each step, we calculate the middle index. The key is to compare the value at `nums[mid]` with the values at the boundaries. If `nums[mid]` is greater than or equal to `nums[left]`, it implies that the portion from `left` to `mid` is sorted correctly, meaning the pivot and minimum element must be in the right half. So, we move `left = mid + 1`. If `nums[mid]` is less than `nums[left]`, it means the pivot is in the left half (including `mid` itself), so we move `right = mid`. We continue this process until `left` and `right` converge. The element at the left pointer will be the minimum. We also need to handle the case where the array is not rotated at all.",
                    "code": {
                        "python": "class Solution:\n    def findMin(self, nums: list[int]) -> int:\n        res = nums[0]\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            if nums[l] < nums[r]:\n                res = min(res, nums[l])\n                break\n            \n            m = (l + r) // 2\n            res = min(res, nums[m])\n            if nums[m] >= nums[l]:\n                l = m + 1\n            else:\n                r = m - 1\n        return res"
                    }
                }
            },
            {
                "id": 33,
                "title": "Search in Rotated Sorted Array",
                "leetcode_url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/search-in-rotated-sorted-array"
                },
                "youtube_id": "U8XENwh8Oy8",
                "hints": [
                    "This requires a modified binary search.",
                    "At each step of the binary search, first determine which half of the array (left or right of `mid`) is sorted. Then, check if the target falls within the range of this sorted half. If it does, search there. Otherwise, search the other half."
                ],
                "solution": {
                    "explanation": "This is a binary search problem where the array is rotated. The key is to modify the binary search logic. In each step, after finding the middle element, we must first identify which side of `mid` is sorted. We can do this by comparing `nums[mid]` with `nums[left]`. If `nums[mid] >= nums[left]`, the left portion is sorted. If not, the right portion is sorted. Once we know which portion is sorted, we can check if our `target` lies within the range of that sorted portion. For example, if the left half is sorted and `target` is between `nums[left]` and `nums[mid]`, we search the left half. Otherwise, we must search the unsorted right half. We repeat this until the target is found or the pointers cross.",
                    "code": {
                        "python": "class Solution:\n    def search(self, nums: list[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n            \n            # left sorted portion\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            # right sorted portion\n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1"
                    }
                }
            },
            {
                "id": 4,
                "title": "Median of Two Sorted Arrays",
                "leetcode_url": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/median-of-two-sorted-arrays"
                },
                "youtube_id": "q6IEA26hvXc",
                "hints": [
                    "This is a very hard problem that can be solved in O(log(m+n)) time.",
                    "The goal is to partition both arrays into a 'left part' and a 'right part' such that every element in the combined left parts is less than or equal to every element in the combined right parts. The median can then be found from the boundary elements."
                ],
                "solution": {
                    "explanation": "The optimal solution involves performing a binary search on the smaller of the two arrays to find the correct partition point. Let's say we are searching on array `A`. A partition in `A` at index `i` determines a corresponding partition in `B` at index `j`. For the partitions to be correct (forming a valid median), two conditions must hold: `A[i-1] <= B[j]` and `B[j-1] <= A[i]`. We binary search for the index `i` in `A` that satisfies these conditions. If `A[i-1] > B[j]`, our partition `i` is too large, so we search the left half. If `B[j-1] > A[i]`, our partition `i` is too small, so we search the right half. Once the correct partitions are found, the median is calculated from the maximum of the left parts and the minimum of the right parts, depending on whether the total length is even or odd.",
                    "code": {
                        "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n        \n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2 # A\n            j = half - i - 2 # B\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i+1] if (i+1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j+1] if (j+1) < len(B) else float(\"infinity\")\n\n            # partition is correct\n            if Aleft <= Bright and Bleft <= Aright:\n                # odd\n                if total % 2:\n                    return min(Aright, Bright)\n                # even\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1"
                    }
                }
            }
        ],
        "Linked List": [
            {
                "id": 206,
                "title": "Reverse Linked List",
                "leetcode_url": "https://leetcode.com/problems/reverse-linked-list/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reverse-linked-list"
                },
                "youtube_id": "G0_I-ZF0S38",
                "hints": [
                    "You can solve this iteratively or recursively.",
                    "For the iterative approach, you'll need two pointers: `prev` and `curr`. As you traverse the list, you rewire the `next` pointer of the `curr` node to point to `prev`."
                ],
                "solution": {
                    "explanation": "To reverse a linked list iteratively, we can traverse the list while changing the direction of the pointers. We need two pointers to keep track of our progress: `prev` (initialized to `None`) and `curr` (initialized to `head`). We iterate as long as `curr` is not `None`. In each iteration, we first save the next node using a temporary variable (`temp = curr.next`). Then, we rewire the current node's pointer to point to our previous node (`curr.next = prev`). After that, we update `prev` to be the current node (`prev = curr`) and `curr` to be the temporary next node we saved (`curr = temp`). This effectively moves us one step down the list while reversing the pointer. After the loop, `prev` will be pointing to the new head of the reversed list.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: [list]) -> [list]:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev"
                    }
                }
            },
            {
                "id": 21,
                "title": "Merge Two Sorted Lists",
                "leetcode_url": "https://leetcode.com/problems/merge-two-sorted-lists/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/merge-two-sorted-lists"
                },
                "youtube_id": "XIdigk956u0",
                "hints": [
                    "Create a dummy node to serve as the starting point of your new merged list.",
                    "Compare the heads of the two lists. Append the smaller one to your merged list and advance the pointer of that list. Repeat until one list is empty."
                ],
                "solution": {
                    "explanation": "We can merge the two sorted lists by creating a new list. We start by creating a dummy `tail` node which will be the head of our new list. We then iterate as long as both input lists (`list1` and `list2`) are not empty. In each step, we compare the values of the current nodes of `list1` and `list2`. We append the smaller of the two nodes to our `tail.next`, and then advance the pointer of the list from which we took the node. We also advance our `tail` pointer. Once one of the lists becomes empty, it means all its elements have been merged. We can then simply append the remainder of the non-empty list to the end of our merged list. Finally, we return `dummy.next`, which is the true head of the merged list.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: [list], list2: [list]) -> [list]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n\n        return dummy.next"
                    }
                }
            },
            {
                "id": 143,
                "title": "Reorder List",
                "leetcode_url": "https://leetcode.com/problems/reorder-list/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reorder-list"
                },
                "youtube_id": "S5bfdUTrKLM",
                "hints": [
                    "This problem can be broken down into three steps.",
                    "1. Find the middle of the linked list. 2. Reverse the second half of the linked list. 3. Merge the first half and the reversed second half."
                ],
                "solution": {
                    "explanation": "The solution involves three main steps. First, we find the middle of the linked list. We can do this using a slow and a fast pointer; when the fast pointer reaches the end, the slow pointer will be at the middle. Second, we reverse the second half of the list starting from the node after the middle. We can use the standard iterative approach for this. After reversing, we set the `next` pointer of the middle node to `None` to split the two halves. Third, we merge the two lists. We take the head of the first half and the head of the reversed second half. We then weave them together by alternating nodes: `first.next` points to `second`, and `second.next` points to the original next of the first node.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: [list]) -> None:\n        # find middle\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # reverse second half\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        # merge two halfs\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2"
                    }
                }
            },
            {
                "id": 19,
                "title": "Remove Nth Node From End of List",
                "leetcode_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/remove-nth-node-from-end-of-list"
                },
                "youtube_id": "XVuQxVej6y8",
                "hints": [
                    "A one-pass solution can be achieved using two pointers.",
                    "Create a gap of `n` nodes between a `left` and `right` pointer. Then, move both pointers simultaneously until the `right` pointer reaches the end of the list. The `left` pointer will then be at the node just before the one to be removed."
                ],
                "solution": {
                    "explanation": "To solve this in a single pass, we can use a two-pointer technique. We initialize two pointers, `left` and `right`, starting at a dummy node that points to the head. We first advance the `right` pointer `n` steps ahead. This creates a fixed-size gap between `left` and `right`. After creating the gap, we move both `left` and `right` pointers one step at a time until the `right` pointer reaches the last node of the list. At this point, the `left` pointer will be positioned exactly before the node that needs to be removed. We can then simply update the `left.next` pointer to `left.next.next`, effectively removing the target node. Using a dummy node simplifies handling edge cases, like removing the head of the list.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: [list], n: int) -> [list]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0 and right:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        # delete\n        left.next = left.next.next\n        return dummy.next"
                    }
                }
            },
            {
                "id": 141,
                "title": "Linked List Cycle",
                "leetcode_url": "https://leetcode.com/problems/linked-list-cycle/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/linked-list-cycle"
                },
                "youtube_id": "gBTe7lFR3vc",
                "hints": [
                    "This is a classic two-pointer problem known as Floyd's Tortoise and Hare algorithm.",
                    "Use a `slow` pointer that moves one step at a time and a `fast` pointer that moves two steps at a time. If there is a cycle, they are guaranteed to meet."
                ],
                "solution": {
                    "explanation": "The problem can be solved efficiently using Floyd's Tortoise and Hare algorithm. We use two pointers, `slow` and `fast`, both initialized to the head of the list. In each iteration, `slow` moves one step forward, and `fast` moves two steps forward. If the linked list has no cycle, the `fast` pointer (or `fast.next`) will eventually become `None`. However, if there is a cycle, the `fast` pointer will eventually lap the `slow` pointer, and they will point to the same node. We can detect this by checking if `slow == fast` inside the loop. If they meet, we have found a cycle and can return `True`. If the loop terminates, it means no cycle was found, so we return `False`.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: [list]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        \n        return False"
                    }
                }
            },
            {
                "id": 2,
                "title": "Add Two Numbers",
                "leetcode_url": "https://leetcode.com/problems/add-two-numbers/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/add-two-numbers"
                },
                "youtube_id": "wgFPrzT-u_w",
                "hints": [
                    "Traverse both lists simultaneously, adding the corresponding digits along with a `carry` from the previous addition.",
                    "You'll need a dummy head node to simplify the process of building the new result list."
                ],
                "solution": {
                    "explanation": "We can solve this by simulating grade-school addition. We create a dummy head for our result list and a `current` pointer. We also initialize a `carry` variable to 0. We iterate as long as either of the input lists (`l1` or `l2`) has nodes, or if there is a remaining `carry`. In each iteration, we get the values from the current nodes of `l1` and `l2` (using 0 if a list is exhausted). We sum these two values with the `carry`. The new digit for our result list is `sum % 10`. The new `carry` is `sum // 10`. We create a new node with this digit, append it to our result list, and advance all relevant pointers (`current`, `l1`, `l2`). Finally, we return `dummy.next`.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: [list], l2: [list]) -> [list]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next"
                    }
                }
            },
            {
                "id": 287,
                "title": "Find the Duplicate Number",
                "leetcode_url": "https://leetcode.com/problems/find-the-duplicate-number/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/find-the-duplicate-number"
                },
                "youtube_id": "wjYhfadeIn4Q",
                "hints": [
                    "This problem can be conceptualized as a linked list cycle detection problem.",
                    "Treat the values in the array as pointers. The value `nums[i]` points to the index `nums[i]`. Since there's a duplicate number, there must be a cycle. Use Floyd's Tortoise and Hare algorithm."
                ],
                "solution": {
                    "explanation": "This problem can be brilliantly mapped to finding the start of a cycle in a linked list. We can view the array `nums` as a linked list where `i -> nums[i]`. Since the numbers are between 1 and n and the array has n+1 elements, there's guaranteed to be a duplicate, which creates a cycle. We can use Floyd's Tortoise and Hare algorithm. We start a `slow` and `fast` pointer at index 0. `slow` moves one step (`slow = nums[slow]`) and `fast` moves two steps (`fast = nums[nums[fast]]`). Once they collide, we know a cycle exists. To find the entrance to the cycle (which corresponds to the duplicate number), we reset one pointer (say, `slow2`) to the start (index 0) and keep the other pointer at the collision point. We then move both pointers one step at a time. The node where they meet is the start of the cycle, and its value is the duplicate number.",
                    "code": {
                        "python": "class Solution:\n    def findDuplicate(self, nums: list[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow"
                    }
                }
            },
            {
                "id": 138,
                "title": "Copy List with Random Pointer",
                "leetcode_url": "https://leetcode.com/problems/copy-list-with-random-pointer/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/copy-list-with-random-pointer"
                },
                "youtube_id": "5Y2EiZST97Y",
                "hints": [
                    "You need a way to map the original nodes to their corresponding new nodes.",
                    "Use a hash map. In the first pass, create a copy of each node and store the mapping: `old_node -> new_node`. In the second pass, iterate through the original list again and set the `next` and `random` pointers for the new nodes using the map."
                ],
                "solution": {
                    "explanation": "This problem can be solved in two passes using a hash map. The hash map will store the mapping from each original node to its newly created copy. In the first pass, we iterate through the original linked list. For each node, we create a new copy of it and store this `old_node -> new_node` mapping in our hash map. In the second pass, we iterate through the original list again. For each original node `curr`, we can now set the pointers for its copy, which we can access via `copyMap[curr]`. The `next` pointer of the copy will be `copyMap[curr.next]`, and the `random` pointer will be `copyMap[curr.random]`. We need to handle the case where `curr.next` or `curr.random` is `None`. The head of our new copied list is simply `copyMap[head]`.",
                    "code": {
                        "python": "# Definition for a Node.\n# class Node:\n#     def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n#         self.val = int(x)\n#         self.next = next\n#         self.random = random\n\nclass Solution:\n    def copyRandomList(self, head: '[list]') -> '[list]':\n        oldToCopy = { None: None }\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        \n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n            \n        return oldToCopy[head]"
                    }
                }
            },
            {
                "id": 25,
                "title": "Reverse Nodes in k-Group",
                "leetcode_url": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reverse-nodes-in-k-group"
                },
                "youtube_id": "1UOPsfP85V4",
                "hints": [
                    "This is a very challenging linked list problem.",
                    "First, determine if there are at least `k` nodes left. If not, you're done. If so, you need to reverse those `k` nodes, and the head of this now-reversed group needs to be connected to the result of the recursive call on the rest of the list."
                ],
                "solution": {
                    "explanation": "This problem can be solved recursively. We define a base case: if the list has fewer than `k` nodes, we don't need to do anything and can just return the head. To check this, we first iterate `k` nodes ahead to find the `k`-th node. If we can't (i.e., we hit `None`), we return. The core of the recursion is to reverse the first `k` nodes. We can use a standard iterative reversal for this, keeping track of the `groupPrev` (the last node of the *previous* k-group) and the `kthNode` (the start of the *next* k-group). After reversing the current group, the original head of this group becomes the new tail. This new tail's `next` pointer must be connected to the result of the recursive call on the rest of the list (`kthNode`). The `groupPrev`'s `next` pointer must be connected to the new head of the reversed group. A dummy node is very helpful to handle the connection for the very first group.",
                    "code": {
                        "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: [list], k: int) -> [list]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            # reverse group\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n            \n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr"
                    }
                }
            },
            {
                "id": 146,
                "title": "LRU Cache",
                "leetcode_url": "https://leetcode.com/problems/lru-cache/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/lru-cache"
                },
                "youtube_id": "7ABFKPK2hD4",
                "hints": [
                    "To achieve O(1) for both `get` and `put`, you need a combination of two data structures.",
                    "Use a hash map for O(1) lookups of keys and a doubly linked list to maintain the order of use."
                ],
                "solution": {
                    "explanation": "The key to an O(1) LRU Cache is combining a hash map and a doubly linked list. The hash map stores `key -> node` pairs, allowing for O(1) access to any node in our list. The doubly linked list maintains the order of use. We use two dummy nodes, `left` (Least Recently Used side) and `right` (Most Recently Used side). When a node is accessed (via `get` or `put`), we move it to the right end of the list, marking it as most recently used. When we `put` a new item and the cache is full, we evict the node at the left end of the list (the LRU node) and remove it from our hash map. The `get` operation involves looking up the key in the map, moving the corresponding node to the MRU position, and returning its value. The `put` operation involves either updating an existing node (and moving it) or inserting a new node at the MRU position.",
                    "code": {
                        "python": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {} # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    # remove node from list\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    # insert node at right\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            # remove from the list and delete the LRU from hashmap\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]"
                    }
                }
            }
        ],
        "Trees": [
            {
                "id": 226,
                "title": "Invert Binary Tree",
                "leetcode_url": "https://leetcode.com/problems/invert-binary-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/invert-binary-tree"
                },
                "youtube_id": "OnSn2Xgl22I",
                "hints": [
                    "This problem can be solved with a simple recursive approach.",
                    "For any given node, swap its left and right children, then recursively call the function on both of those children."
                ],
                "solution": {
                    "explanation": "The most intuitive solution is recursive. The base case for the recursion is an empty node (a `None` node), in which case we simply return. For any non-empty node, we perform one simple operation: we swap its left and right children. After swapping, we make a recursive call to the same function for the (new) left child and the (new) right child. This process continues down the tree, and once all calls have returned, the entire tree will be inverted.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: [list]) -> [list]:\n        if not root:\n            return None\n\n        # swap the children\n        tmp = root.left\n        root.left = root.right\n        root.right = tmp\n\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"
                    }
                }
            },
            {
                "id": 104,
                "title": "Maximum Depth of Binary Tree",
                "leetcode_url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/maximum-depth-of-binary-tree"
                },
                "youtube_id": "hTM3phVI6YQ",
                "hints": [
                    "What is the depth of an empty tree?",
                    "The maximum depth of a node is `1 + max(depth_of_left_subtree, depth_of_right_subtree)`."
                ],
                "solution": {
                    "explanation": "This problem can be elegantly solved using recursion. The base case is when we reach a null node, which has a depth of 0. For any non-null node, its maximum depth is 1 (for the node itself) plus the maximum of the depths of its left and right subtrees. So, we can define a recursive function that returns `1 + max(maxDepth(root.left), maxDepth(root.right))`. This Depth First Search (DFS) approach naturally explores the tree down to its leaf nodes and bubbles up the maximum depth from each path.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: [list]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
                    }
                }
            },
            {
                "id": 543,
                "title": "Diameter of Binary Tree",
                "leetcode_url": "https://leetcode.com/problems/diameter-of-binary-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/diameter-of-binary-tree"
                },
                "youtube_id": "bkK_d-gn4d4",
                "hints": [
                    "The diameter of a tree is the longest path between any two nodes. This path may or may not pass through the root.",
                    "For each node, the longest path that passes through it is `depth_of_left_subtree + depth_of_right_subtree`. You need to calculate this for every node and find the maximum."
                ],
                "solution": {
                    "explanation": "The solution requires a modification of the depth calculation. We can use a recursive Depth First Search (DFS) function that calculates the height of a node's subtree. Inside this DFS function, we do two things: 1. We recursively call it for the left and right children to get their heights. 2. For the current node, we calculate the diameter that passes through it, which is `height(left) + height(right)`. We keep a global or class-level variable to track the maximum diameter found across all nodes. The DFS function itself returns the height of the current subtree, which is `1 + max(height(left), height(right))`, so that its parent can use this value to calculate its own diameter.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: [list]) -> int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return res"
                    }
                }
            },
            {
                "id": 110,
                "title": "Balanced Binary Tree",
                "leetcode_url": "https://leetcode.com/problems/balanced-binary-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/balanced-binary-tree"
                },
                "youtube_id": "QfJsau0ItOY",
                "hints": [
                    "A tree is height-balanced if, for every node, the height difference between its left and right subtrees is at most 1.",
                    "Use a recursive approach that returns two pieces of information for each node: whether it is balanced, and its height."
                ],
                "solution": {
                    "explanation": "This can be solved with a recursive DFS approach. We define a helper function that, for any given node, returns its height. However, we modify it to also check the balance condition. The base case is a null node, which is balanced and has a height of -1 (or 0, depending on convention). For any other node, we recursively call the helper on its left and right children. This gives us their heights. We check if the absolute difference between these heights is greater than 1. If it is, or if either of the recursive calls reported an imbalance, we know the tree is not balanced. We can propagate this 'unbalanced' state upwards, for instance, by returning a special value like `False`. If it is balanced, the function returns the node's height `1 + max(left_height, right_height)`.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: [list]) -> bool:\n        \n        def dfs(root):\n            if not root: return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = (left[0] and right[0] and\n                        abs(left[1] - right[1]) <= 1)\n            \n            return [balanced, 1 + max(left[1], right[1])]\n        \n        return dfs(root)[0]"
                    }
                }
            },
            {
                "id": 100,
                "title": "Same Tree",
                "leetcode_url": "https://leetcode.com/problems/same-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/same-tree"
                },
                "youtube_id": "vRbbcKXCxOw",
                "hints": [
                    "Two trees are the same if their root nodes have the same value, and their left subtrees are the same, and their right subtrees are the same.",
                    "This structure suggests a simple recursive solution."
                ],
                "solution": {
                    "explanation": "This problem is a perfect fit for recursion. We define a function that takes two nodes, `p` and `q`. The base cases are crucial. If both `p` and `q` are `None`, they are the same, so we return `True`. If one is `None` but the other is not, or if their values are different, they are not the same, so we return `False`. If the nodes themselves are valid and have the same value, the condition for them being the same trees depends on their children. We then return the result of the logical AND of two recursive calls: one comparing the left children (`p.left`, `q.left`) and one comparing the right children (`p.right`, `q.right`).",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: [list], q: [list]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        \n        return (self.isSameTree(p.left, q.left) and\n                self.isSameTree(p.right, q.right))"
                    }
                }
            },
            {
                "id": 572,
                "title": "Subtree of Another Tree",
                "leetcode_url": "https://leetcode.com/problems/subtree-of-another-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/subtree-of-another-tree"
                },
                "youtube_id": "E36O5SWp-LE",
                "hints": [
                    "You'll likely need a helper function. Consider a function `isSameTree(p, q)` from the previous problem.",
                    "Traverse the main tree (`root`). For each node you visit, use your `isSameTree` helper to check if the subtree starting at that node is identical to `subRoot`."
                ],
                "solution": {
                    "explanation": "This problem can be solved by combining traversal with a comparison function. We can reuse the logic from the 'Same Tree' problem in a helper function, `isSameTree`. The main function will traverse the larger tree (`root`). For each node encountered in `root`, we check if the subtree rooted at this node is the same as `subRoot` by calling our `isSameTree` helper. If it is, we've found our match and can return `True`. If not, we continue the search by recursively checking the left and right children of the current node in the main tree. If we traverse the entire main tree without finding a matching subtree, we return `False`.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: [list], subRoot: [list]) -> bool:\n        if not subRoot: return True\n        if not root: return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return (self.isSubtree(root.left, subRoot) or\n                self.isSubtree(root.right, subRoot))\n\n    def sameTree(self, s, t):\n        if not s and not t:\n            return True\n        if s and t and s.val == t.val:\n            return (self.sameTree(s.left, t.left) and\n                    self.sameTree(s.right, t.right))\n        return False"
                    }
                }
            },
            {
                "id": 235,
                "title": "Lowest Common Ancestor of a Binary Search Tree",
                "leetcode_url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/lowest-common-ancestor-of-a-binary-search-tree"
                },
                "youtube_id": "gs2LMfuOR9k",
                "hints": [
                    "Leverage the properties of a Binary Search Tree (BST).",
                    "For any given node, if both target nodes `p` and `q` are on one side (both have values greater than the current node, or both have values less than), then the LCA must be on that side. If they are on opposite sides, the current node is the LCA."
                ],
                "solution": {
                    "explanation": "Because this is a Binary Search Tree, we can solve this problem very efficiently. We start at the root of the tree. At each node, we compare its value with the values of `p` and `q`. If both `p.val` and `q.val` are greater than the current node's value, it means both nodes are in the right subtree, so we traverse to the right child. If both are smaller, we traverse to the left child. If the current node's value is between `p.val` and `q.val` (or equal to one of them), it means the paths to `p` and `q` have split. This current node is therefore the lowest common ancestor. This iterative approach is very efficient as it avoids a full tree traversal.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        cur = root\n\n        while cur:\n            if p.val > cur.val and q.val > cur.val:\n                cur = cur.right\n            elif p.val < cur.val and q.val < cur.val:\n                cur = cur.left\n            else:\n                return cur"
                    }
                }
            },
            {
                "id": 102,
                "title": "Binary Tree Level Order Traversal",
                "leetcode_url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/binary-tree-level-order-traversal"
                },
                "youtube_id": "6ZnyEApgFYg",
                "hints": [
                    "This requires a Breadth-First Search (BFS) approach.",
                    "Use a queue. In each step of the loop, process all the nodes currently in the queue (which constitutes one level), and add their children to the queue for the next iteration."
                ],
                "solution": {
                    "explanation": "Level order traversal is synonymous with Breadth-First Search (BFS). We use a queue to keep track of the nodes to visit. We initialize the queue with the root node. Then, we loop as long as the queue is not empty. Inside the loop, we first get the number of nodes currently in the queue, as this represents the number of nodes in the current level. We then process exactly that many nodes, dequeuing each one, adding its value to a temporary list for the current level, and enqueuing its non-null children. After the inner loop finishes, we add the list of values for the completed level to our final result list.",
                    "code": {
                        "python": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: [list]) -> list[list[int]]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res"
                    }
                }
            },
            {
                "id": 199,
                "title": "Binary Tree Right Side View",
                "leetcode_url": "https://leetcode.com/problems/binary-tree-right-side-view/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/binary-tree-right-side-view"
                },
                "youtube_id": "d4zLyf32e3I",
                "hints": [
                    "This can be solved with a Breadth-First Search (BFS) level order traversal.",
                    "During a level order traversal, the very last node you process in each level is the rightmost node. Add this node's value to your result."
                ],
                "solution": {
                    "explanation": "The problem asks for the rightmost node of each level. This can be solved perfectly with a Breadth-First Search (BFS) that performs a level order traversal. We use a queue, initialized with the root. We loop level by level. In each iteration of the main loop, we get the size of the queue, which tells us how many nodes are on the current level. We then process all nodes on this level. The key is to add only the value of the very last node processed in this inner loop to our result list. This last node is guaranteed to be the rightmost one. We add the children of all nodes in the level to the queue for the next iteration.",
                    "code": {
                        "python": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: [list]) -> list[int]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    if node.left:\n                        q.append(node.left)\n                    if node.right:\n                        q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res"
                    }
                }
            },
            {
                "id": 98,
                "title": "Validate Binary Search Tree",
                "leetcode_url": "https://leetcode.com/problems/validate-binary-search-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/validate-binary-search-tree"
                },
                "youtube_id": "s6ATEkipzow",
                "hints": [
                    "It's not enough to check that `node.left.val < node.val` and `node.right.val > node.val`. The entire left subtree must be less than the node, and the entire right subtree must be greater.",
                    "Use a recursive approach, but pass down the valid range (`min`, `max`) that each node's value must fall into."
                ],
                "solution": {
                    "explanation": "A simple comparison with the immediate children is not sufficient. The BST property must hold for the entire subtree. A robust solution uses a recursive DFS approach where we pass down the valid range of values for each node. We define a helper function `isValid(node, left_boundary, right_boundary)`. For a node to be valid, its value must be greater than `left_boundary` and less than `right_boundary`. The base case is a null node, which is always valid. For the recursive step, when we traverse to the left child, we update the right boundary to be the current node's value. When we traverse to the right child, we update the left boundary to be the current node's value. If any node violates its boundary conditions, we propagate `False` up the call stack.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: [list]) -> bool:\n\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n            \n            return (valid(node.left, left, node.val) and\n                    valid(node.right, node.val, right))\n        \n        return valid(root, float(\"-inf\"), float(\"inf\"))"
                    }
                }
            },
            {
                "id": 230,
                "title": "Kth Smallest Element in a BST",
                "leetcode_url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/kth-smallest-element-in-a-bst"
                },
                "youtube_id": "5LUXSvjmGCw",
                "hints": [
                    "What is the property of an in-order traversal of a BST?",
                    "An in-order traversal visits the nodes of a BST in ascending sorted order."
                ],
                "solution": {
                    "explanation": "The key property of a Binary Search Tree (BST) is that an in-order traversal of the tree yields the node values in non-decreasing sorted order. We can leverage this to find the k-th smallest element. We can perform an iterative in-order traversal using a stack. We traverse as far left as possible from the current node, adding each node to the stack. Once we can't go left anymore, we pop a node from the stack. This is the next smallest element. We decrement `k`. If `k` becomes 0, we have found our target element and can return its value. If not, we move to the right child of the popped node and repeat the process.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: [list], k: int) -> int:\n        stack = []\n        curr = root\n\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right"
                    }
                }
            },
            {
                "id": 105,
                "title": "Construct Binary Tree from Preorder and Inorder Traversal",
                "leetcode_url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/construct-binary-tree-from-preorder-and-inorder-traversal"
                },
                "youtube_id": "ihj4IQGZ2oM",
                "hints": [
                    "The first element in the preorder traversal is always the root of the (sub)tree.",
                    "In the inorder traversal, all elements to the left of the root belong to the left subtree, and all elements to the right belong to the right subtree."
                ],
                "solution": {
                    "explanation": "This problem can be solved with a recursive approach. The key insight lies in the properties of the traversals. The first element of the `preorder` list is always the root of the current tree. We can find this root value in the `inorder` list. The elements to the left of this root in the `inorder` list form the left subtree, and the elements to the right form the right subtree. The number of elements in the left subtree (let's say `mid`) tells us how to slice the `preorder` list for the recursive calls. The left subtree will be built from the next `mid` elements in the `preorder` list, and the right subtree will be built from the rest. We can then recursively call our build function for the left and right subtrees with their corresponding slices of the preorder and inorder arrays.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> [list]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"
                    }
                }
            },
            {
                "id": 124,
                "title": "Binary Tree Maximum Path Sum",
                "leetcode_url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/binary-tree-maximum-path-sum"
                },
                "youtube_id": "Hr5cWUld4vU",
                "hints": [
                    "A path can start and end at any node. It doesn't have to go through the root.",
                    "Use a recursive helper function. For each node, you need to decide whether to 'split' the path (using both left and right children) or to extend a path from one of its children upwards to its parent."
                ],
                "solution": {
                    "explanation": "This is a challenging tree problem that can be solved with a recursive DFS. We need a helper function that does two things for each node: 1. It computes the maximum path sum that includes the current node and can be extended upwards to its parent. This value would be `node.val + max(left_path_sum, right_path_sum)` (ignoring negative path sums). This is what the function returns. 2. It calculates the maximum path sum that uses the current node as the highest point (a 'split' point), which is `node.val + left_path_sum + right_path_sum`. This value is not returned but is used to update a global or class-level result variable. We recursively call this helper for all nodes, and the global variable will hold the final answer.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: [list]) -> int:\n        res = [root.val]\n\n        # return max path sum without split\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            # compute max path sum WITH split\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]"
                    }
                }
            },
            {
                "id": 297,
                "title": "Serialize and Deserialize Binary Tree",
                "leetcode_url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/serialize-and-deserialize-binary-tree"
                },
                "youtube_id": "u4JAi2JJhI8",
                "hints": [
                    "To serialize the tree, you can use a traversal method like Pre-order DFS.",
                    "When serializing, you must also encode the null nodes (e.g., with a special character like 'N') to preserve the structure of the tree."
                ],
                "solution": {
                    "explanation": "Serialization can be done using a pre-order traversal (DFS). We define a recursive function that builds a list of string values. When it encounters a node, it appends the node's value (as a string) to the list. When it encounters a null pointer, it appends a special marker, like 'N'. The final serialized string is just the comma-separated version of this list. For deserialization, we convert this string back into a list of values. We then use a global pointer or an iterator to traverse this list. We define a recursive function that reads from the list. If it reads 'N', it returns `None`. Otherwise, it creates a new `TreeNode` with the current value, and then recursively calls itself to build the left and right children. This mirrors the pre-order traversal used for serialization, perfectly reconstructing the tree.",
                    "code": {
                        "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return \",\".join(res)\n        \n    def deserialize(self, data):\n        vals = data.split(',')\n        self.i = 0\n\n        def dfs():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()"
                    }
                }
            }
        ],
        "Tries": [
            {
                "id": 208,
                "title": "Implement Trie (Prefix Tree)",
                "leetcode_url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/implement-trie-prefix-tree"
                },
                "youtube_id": "o-Yp3hGfp2E",
                "hints": [
                    "A Trie is a tree-like data structure where each node represents a character.",
                    "Each node should contain a dictionary or array to store its children, and a boolean flag to mark the end of a complete word."
                ],
                "solution": {
                    "explanation": "A Trie is implemented using nodes. Each node contains a dictionary (or hash map) called `children` to map a character to its child node, and a boolean flag, `endOfWord`, which indicates if the path to this node forms a complete word. The Trie starts with an empty root node. To `insert` a word, we traverse from the root, character by character. If a character does not have a corresponding node in the current node's `children`, we create one. We continue until the end of the word and then set the `endOfWord` flag of the final node to `True`. To `search` for a word, we traverse the Trie similarly. If we can traverse the entire word, and the final node's `endOfWord` flag is `True`, the word exists. For `startsWith`, the logic is the same as search, but we don't need to check the `endOfWord` flag; we just need to successfully traverse the prefix.",
                    "code": {
                        "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.endOfWord = True\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return cur.endOfWord\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for c in prefix:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return True"
                    }
                }
            },
            {
                "id": 211,
                "title": "Design Add and Search Words Data Structure",
                "leetcode_url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/design-add-and-search-words-data-structure"
                },
                "youtube_id": "BTf05gs_8iU",
                "hints": [
                    "A Trie is the right data structure for this. The `addWord` method is a standard Trie insert.",
                    "How do you handle the wildcard '.' character? Your search method will need to become a recursive backtracking (DFS) function."
                ],
                "solution": {
                    "explanation": "This problem extends the Trie data structure to handle a wildcard '.' character during search. The `addWord` function is a standard Trie insert. The `search` function becomes more complex. We implement it using a recursive Depth-First Search (DFS) helper. The DFS function takes the current search index and the current Trie node. If the current character is not a wildcard, we simply try to traverse to the next node; if the path doesn't exist, it's a `False`. If the character is a '.', we must explore every child of the current node. We iterate through all nodes in the current node's `children` map and make a recursive call for each one. If any of these recursive calls eventually return `True`, it means we've found a match. The base case for the recursion is reaching the end of the word, at which point we return `True` only if the current node's `endOfWord` flag is set.",
                    "code": {
                        "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        curr = self.root\n        for c in word:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.isWord = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            curr = root\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == '.':\n                    for child in curr.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in curr.children:\n                        return False\n                    curr = curr.children[c]\n            return curr.isWord\n        return dfs(0, self.root)"
                    }
                }
            },
            {
                "id": 212,
                "title": "Word Search II",
                "leetcode_url": "https://leetcode.com/problems/word-search-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/word-search-ii"
                },
                "youtube_id": "asbcE9mZz_U",
                "hints": [
                    "A naive approach of running DFS on the grid for every single word will be too slow (Time Limit Exceeded).",
                    "The efficient approach is to build a Trie from all the words, and then perform a single, combined DFS on the grid that traverses the Trie at the same time."
                ],
                "solution": {
                    "explanation": "This problem is efficiently solved by combining a Trie and a backtracking DFS. First, we build a Trie containing all the words from the input list. This allows us to search for multiple words simultaneously. Then, we perform a DFS starting from every cell on the board. The DFS function will explore the grid, and at the same time, it will traverse the Trie. At each cell `(r, c)`, we check if the character `board[r][c]` exists as a child of the current Trie node. If it doesn't, we can prune the search path immediately. If it does, we move to that child node and continue the DFS. If we reach a Trie node that marks the end of a word, we add that word to our result set. We use backtracking by marking visited cells (e.g., by changing the character to '#') to avoid using the same letter twice in a word, and we revert the change after exploring from that cell.",
                    "code": {
                        "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n    \n    def addWord(self, word):\n        cur = self\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.isWord = True\n\nclass Solution:\n    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n            \n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n        \n        def dfs(r, c, node, word):\n            if (r < 0 or c < 0 or\n                r == ROWS or c == COLS or\n                (r, c) in visit or board[r][c] not in node.children):\n                return\n            \n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                res.add(word)\n            \n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(c + 1, r, node, word) # Typo in original NeetCode, should be dfs(r, c + 1, ...)\n            dfs(c - 1, r, node, word) # Typo in original NeetCode, should be dfs(r, c - 1, ...)\n            visit.remove((r,c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n        \n        return list(res)"
                    }
                }
            }
        ],
        "Heap / Priority Queue": [
            {
                "id": 703,
                "title": "Kth Largest Element in a Stream",
                "leetcode_url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/kth-largest-element-in-a-stream"
                },
                "youtube_id": "hOjcdrqMoQ8",
                "hints": [
                    "The goal is to efficiently find the k-th largest element after each addition.",
                    "A min-heap of a fixed size `k` is the ideal data structure for this. The top of the min-heap will always be the k-th largest element."
                ],
                "solution": {
                    "explanation": "To solve this, we maintain a min-heap that stores only the `k` largest elements seen so far. In the constructor, we initialize our heap. For each number in the initial list, we call our `add` method. The `add` method is the core of the logic: we push the new value onto the min-heap. If, after pushing, the size of our heap is greater than `k`, it means we have `k+1` elements, and the smallest of these (which is at the top of the min-heap) is not one of the `k` largest. So, we pop it. After this operation, the heap is back to size `k`, and the element at the top is the k-th largest element, which we can return.",
                    "code": {
                        "python": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]"
                    }
                }
            },
            {
                "id": 1046,
                "title": "Last Stone Weight",
                "leetcode_url": "https://leetcode.com/problems/last-stone-weight/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/last-stone-weight"
                },
                "youtube_id": "B-CqSA8UqsU",
                "hints": [
                    "You repeatedly need to find and remove the two largest elements. What data structure is efficient for this?",
                    "A max-heap is perfect. Since Python's `heapq` is a min-heap, you can simulate a max-heap by storing the negative values of the stones."
                ],
                "solution": {
                    "explanation": "Since we always need to access the two heaviest stones, a max-heap is the ideal data structure. Python's `heapq` module implements a min-heap, but we can easily simulate a max-heap by storing the negated values of the stones. We first convert all stone weights to negative and `heapify` the list. Then, as long as we have more than one stone in our heap, we pop the two largest stones (which will be the two smallest values in our min-heap). We simulate the smash: if the stones are different, we calculate the new weight, negate it, and push it back onto the heap. If the heap is empty after the process, we return 0. Otherwise, we return the positive value of the single remaining stone.",
                    "code": {
                        "python": "import heapq\n\nclass Solution:\n    def lastStoneWeight(self, stones: list[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])"
                    }
                }
            },
            {
                "id": 215,
                "title": "Kth Largest Element in an Array",
                "leetcode_url": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/kth-largest-element-in-an-array"
                },
                "youtube_id": "_l3hLL4p-lE",
                "hints": [
                    "Sorting the array and picking the k-th element from the end is a simple O(n log n) solution.",
                    "A more optimal solution with O(n) average time complexity is the Quickselect algorithm, which is a modification of Quicksort."
                ],
                "solution": {
                    "explanation": "Quickselect is an efficient algorithm to find the k-th smallest/largest element in an unordered list. It's very similar to Quicksort. We first choose a 'pivot' element from the array. Then, we partition the array around the pivot, placing all elements smaller than the pivot to its left and all elements larger to its right. After partitioning, the pivot is in its final sorted position. Let's say this position is `p`. We can compare `p` with our target index `k`. If `p > k`, we know the element we're looking for is in the left subarray. If `p < k`, it's in the right subarray. If `p == k`, we've found our element. We recursively apply this process to the smaller subarray until we find the element at the k-th position. This has an average time complexity of O(n).",
                    "code": {
                        "python": "class Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        k = len(nums) - k\n\n        def quickSelect(l, r):\n            pivot, p = nums[r], l\n            for i in range(l, r):\n                if nums[i] <= pivot:\n                    nums[p], nums[i] = nums[i], nums[p]\n                    p += 1\n            nums[p], nums[r] = nums[r], nums[p]\n            \n            if p > k:   return quickSelect(l, p - 1)\n            elif p < k: return quickSelect(p + 1, r)\n            else:       return nums[p]\n\n        return quickSelect(0, len(nums) - 1)"
                    }
                }
            },
            {
                "id": 973,
                "title": "K Closest Points to Origin",
                "leetcode_url": "https://leetcode.com/problems/k-closest-points-to-origin/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/k-closest-points-to-origin"
                },
                "youtube_id": "rI2EBUEMf-o",
                "hints": [
                    "The distance from the origin (0,0) to a point (x,y) is `sqrt(x^2 + y^2)`. To compare distances, you only need to compare the squared distances `x^2 + y^2`.",
                    "A min-heap is a good way to store all the points and their distances, then retrieve the smallest `k`."
                ],
                "solution": {
                    "explanation": "To find the `k` closest points, we first need to calculate the distance of each point from the origin. The Euclidean distance is `sqrt(x^2 + y^2)`. To simplify and avoid dealing with floating-point numbers from square roots, we can just work with the squared distance, `x^2 + y^2`, since the order will be the same. We can iterate through all the points, calculate their squared distances, and push tuples of `(distance, x, y)` into a min-heap. After pushing all the points, the heap will be ordered by distance. We can then simply pop from the heap `k` times to get the `k` points with the smallest distances.",
                    "code": {
                        "python": "import heapq\n\nclass Solution:\n    def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) + (y ** 2)\n            minHeap.append([dist, x, y])\n        \n        heapq.heapify(minHeap)\n        \n        res = []\n        while k > 0:\n            dist, x, y = heapq.heappop(minHeap)\n            res.append([x, y])\n            k -= 1\n        return res"
                    }
                }
            },
            {
                "id": 215,
                "title": "Kth Largest Element in an Array",
                "leetcode_url": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/kth-largest-element-in-an-array"
                },
                "youtube_id": "_l3hLL4p-lE",
                "hints": [
                    "Sorting the array and picking the k-th element from the end is a simple O(n log n) solution.",
                    "A more optimal solution with O(n) average time complexity is the Quickselect algorithm, which is a modification of Quicksort."
                ],
                "solution": {
                    "explanation": "Quickselect is an efficient algorithm to find the k-th smallest/largest element in an unordered list. It's very similar to Quicksort. We first choose a 'pivot' element from the array. Then, we partition the array around the pivot, placing all elements smaller than the pivot to its left and all elements larger to its right. After partitioning, the pivot is in its final sorted position. Let's say this position is `p`. We can compare `p` with our target index `k`. If `p > k`, we know the element we're looking for is in the left subarray. If `p < k`, it's in the right subarray. If `p == k`, we've found our element. We recursively apply this process to the smaller subarray until we find the element at the k-th position. This has an average time complexity of O(n).",
                    "code": {
                        "python": "class Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        k = len(nums) - k\n\n        def quickSelect(l, r):\n            pivot, p = nums[r], l\n            for i in range(l, r):\n                if nums[i] <= pivot:\n                    nums[p], nums[i] = nums[i], nums[p]\n                    p += 1\n            nums[p], nums[r] = nums[r], nums[p]\n            \n            if p > k:   return quickSelect(l, p - 1)\n            elif p < k: return quickSelect(p + 1, r)\n            else:       return nums[p]\n\n        return quickSelect(0, len(nums) - 1)"
                    }
                }
            },
            {
                "id": 621,
                "title": "Task Scheduler",
                "leetcode_url": "https://leetcode.com/problems/task-scheduler/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/task-scheduler"
                },
                "youtube_id": "s8p8ukTyA2I",
                "hints": [
                    "A greedy approach works best. At each time unit, schedule the most frequent task that is not on cooldown.",
                    "Use a max-heap to store the frequencies of tasks. Use a queue to handle the cooldown period."
                ],
                "solution": {
                    "explanation": "This problem can be modeled as a greedy simulation. We want to execute the most frequent tasks first. We use a max-heap to store the counts of each task. Since Python has a min-heap, we store negative counts. We also use a queue to keep track of tasks that are on cooldown. The main loop simulates time. In each time step, we check if any task in the cooldown queue is ready to be scheduled again (i.e., `time >= task_cooldown_end_time`). If so, we add its count back to the max-heap. Then, if the max-heap is not empty, we pick the most frequent task, decrement its count, and if it still needs to run, we add it to the cooldown queue with its next available time, which is `time + n`. We increment our time variable in every iteration, regardless of whether a task was scheduled (idle time) or not.",
                    "code": {
                        "python": "import heapq\nfrom collections import Counter, deque\n\nclass Solution:\n    def leastInterval(self, tasks: list[str], n: int) -> int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque() # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if maxHeap:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time"
                    }
                }
            },
            {
                "id": 355,
                "title": "Design Twitter",
                "leetcode_url": "https://leetcode.com/problems/design-twitter/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/design-twitter"
                },
                "youtube_id": "pB-bFAe6H5E",
                "hints": [
                    "The most complex part is `getNewsFeed`. You need to merge the k-sorted lists of recent tweets from the user and everyone they follow.",
                    "A max-heap is the ideal data structure to merge k sorted lists and find the most recent items."
                ],
                "solution": {
                    "explanation": "To design this system, we need a way to store user-follow relationships (a hash map of user to a set of followed users) and a way to store tweets. We can store tweets in a simple list, using the list index as a timestamp. The core challenge is `getNewsFeed`. When a user requests their feed, we need the 10 most recent tweets from themselves and all users they follow. This is a classic 'merge k-sorted lists' problem. We can use a max-heap to solve this efficiently. We find the most recent tweet for each relevant user and add a tuple `(timestamp, tweet_id, user_id, tweet_index)` to our max-heap. We then pop from the heap 10 times. Each time we pop a tweet, we add it to our result. Then, we find the next tweet from the same user (if one exists) and add it to the heap. This ensures we are always considering the most recent tweet across all feeds.",
                    "code": {
                        "python": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list) # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set) # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        res = []\n        minHeap = []\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)"
                    }
                }
            },
            {
                "id": 295,
                "title": "Find Median from Data Stream",
                "leetcode_url": "https://leetcode.com/problems/find-median-from-data-stream/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/find-median-from-data-stream"
                },
                "youtube_id": "itmhZeU4Up0",
                "hints": [
                    "The median divides a sorted list into two equal halves.",
                    "You can use two heaps to maintain these two halves: a max-heap for the smaller half and a min-heap for the larger half."
                ],
                "solution": {
                    "explanation": "The core idea is to maintain two heaps. A max-heap, `small`, will store the smaller half of the numbers, and a min-heap, `large`, will store the larger half. We enforce two properties: 1. All numbers in `small` are less than or equal to all numbers in `large`. 2. The heaps are kept balanced, with their sizes being either equal or with `small` having one more element than `large`. When we `addNum`, we can push it to the `small` heap. Since this might violate our first property, we immediately pop the largest element from `small` and push it to `large`. Then, to rebalance, if `large` has more elements than `small`, we pop the smallest from `large` and push it to `small`. To `findMedian`, if the heaps have different sizes, the median is the top of the larger heap (`small`). If they have the same size, the median is the average of the tops of both heaps.",
                    "code": {
                        "python": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small, self.large = [], []\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -1 * num)\n\n        # make sure every num in small is <= every num in large\n        if (self.small and self.large and \n            (-1 * self.small[0]) > self.large[0]):\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # uneven size?\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        if len(self.large) > len(self.small):\n            return self.large[0]\n        \n        return (-1 * self.small[0] + self.large[0]) / 2.0"
                    }
                }
            }
        ],
        "Backtracking": [
            {
                "id": 78,
                "title": "Subsets",
                "leetcode_url": "https://leetcode.com/problems/subsets/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/subsets"
                },
                "youtube_id": "REOH22Xwdkk",
                "hints": [
                    "This is a classic backtracking problem.",
                    "Consider building a decision tree. For each number in the input array, you have two choices: either include it in the current subset, or don't include it."
                ],
                "solution": {
                    "explanation": "This problem can be solved using a backtracking approach. We define a recursive DFS function that builds the subsets. The function takes a starting index `i` and the current subset being built, `subset`. The base case is when we first enter the function; we add a copy of the current `subset` to our main result list. This captures subsets of all possible lengths. In the recursive step, we loop from the starting index `i` to the end of the input `nums` array. In each iteration of the loop, we make a decision: we 'include' the current number `nums[j]` by adding it to our `subset`. Then, we make a recursive call `dfs(j + 1, subset)` to build further subsets from this new state. After the recursive call returns, we 'backtrack' by popping the number `nums[j]` from our `subset`, effectively exploring the path where we don't include this number.",
                    "code": {
                        "python": "class Solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset.copy())\n                return\n            \n            # decision to include nums[i]\n            subset.append(nums[i])\n            dfs(i + 1)\n\n            # decision NOT to include nums[i]\n            subset.pop()\n            dfs(i + 1)\n        \n        dfs(0)\n        return res"
                    }
                }
            },
            {
                "id": 39,
                "title": "Combination Sum",
                "leetcode_url": "https://leetcode.com/problems/combination-sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/combination-sum"
                },
                "youtube_id": "GBKI9VSKdGg",
                "hints": [
                    "This is another backtracking problem.",
                    "Unlike the Subsets problem, you can reuse the same element multiple times. How does this change the recursive call?"
                ],
                "solution": {
                    "explanation": "This is a classic backtracking problem. We use a recursive DFS function that takes a starting index `i`, the current combination `cur`, and the current total `total`. There are two base cases for our recursion. If `total` equals the `target`, we've found a valid combination, so we add a copy of `cur` to our result. If `total` exceeds `target` or our index `i` goes out of bounds, we stop that path. The recursive decision is to try including the number `candidates[i]` in our combination. We add it to `cur` and make a recursive call `dfs(i, ..., total + candidates[i])`. Importantly, we pass the same index `i` to allow for reusing the same element. After this call returns, we backtrack by popping the element from `cur` and then make another recursive call for the path where we don't use `candidates[i]` anymore, `dfs(i + 1, ..., total)`.",
                    "code": {
                        "python": "class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i >= len(candidates) or total > target:\n                return\n            \n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n        \n        dfs(0, [], 0)\n        return res"
                    }
                }
            },
            {
                "id": 46,
                "title": "Permutations",
                "leetcode_url": "https://leetcode.com/problems/permutations/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/permutations"
                },
                "youtube_id": "s7AvT7cGdSo",
                "hints": [
                    "This can be solved with backtracking.",
                    "For each position in the permutation, you can choose any number from the input array that has not already been used."
                ],
                "solution": {
                    "explanation": "We can generate all permutations using recursion with backtracking. A simple way is to build the permutations. The base case for the recursion is when the current permutation has the same length as the input `nums` array; at this point, we add a copy of it to our result list. In the recursive step, we iterate through every number in the original `nums` array. If the number is not already in our current permutation (to avoid using the same element twice in one permutation), we add it. We then make a recursive call to continue building the permutation. After the call returns, we backtrack by removing the number we just added, allowing it to be used in a different position in other permutations.",
                    "code": {
                        "python": "class Solution:\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        \n        if len(nums) == 1:\n            return [nums[:]]\n        \n        for i in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n            \n            for p in perms:\n                p.append(n)\n            res.extend(perms)\n            nums.append(n)\n        return res"
                    }
                }
            },
            {
                "id": 90,
                "title": "Subsets II",
                "leetcode_url": "https://leetcode.com/problems/subsets-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/subsets-ii"
                },
                "youtube_id": "Vn2v6ajA7U0",
                "hints": [
                    "This is very similar to the Subsets problem, but now the input array can contain duplicates.",
                    "To avoid duplicate subsets in the result, first sort the input array. Then, in your backtracking logic, if you're about to use a number that is the same as the previous one, you can only use it if you also used the previous one."
                ],
                "solution": {
                    "explanation": "This problem builds on the standard 'Subsets' problem by introducing duplicate numbers. To handle this, we must first sort the input `nums` array. This places all duplicate numbers next to each other. We then use the same backtracking DFS approach as before. The key modification is in our recursive loop. When we are considering whether to include `nums[i]`, we add a condition: if `i > start_index` and `nums[i] == nums[i-1]`, we must skip this number. This condition ensures that for any duplicate numbers, we only generate subsets starting with the *first* occurrence of that number. All other subsets that would be generated by the subsequent duplicate numbers would be duplicates of ones we've already created. This simple check effectively prunes the decision tree to avoid duplicate results.",
                    "code": {
                        "python": "class Solution:\n    def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            # All subsets that include nums[i]\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n            # All subsets that don't include nums[i]\n            while i + 1 < len(nums) and nums[i] == nums[i+1]:\n                i += 1\n            backtrack(i + 1, subset)\n\n        backtrack(0, [])\n        return res"
                    }
                }
            },
            {
                "id": 40,
                "title": "Combination Sum II",
                "leetcode_url": "https://leetcode.com/problems/combination-sum-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/combination-sum-ii"
                },
                "youtube_id": "rSA3t6BDDwg",
                "hints": [
                    "This is a combination of 'Combination Sum' and 'Subsets II'. The input might have duplicates, and each number can only be used once in each combination.",
                    "Sort the input array. Use a backtracking approach. The key is to skip duplicate numbers to avoid duplicate combinations in the result."
                ],
                "solution": {
                    "explanation": "This problem requires a backtracking approach similar to 'Combination Sum', but with two key differences: each number can be used only once, and the input may contain duplicates. First, we must sort the `candidates` array to handle duplicates easily. We use a recursive DFS function. The base cases are when the `target` becomes 0 (we found a valid combination) or negative (invalid path). In our recursive loop, we iterate through the candidates. The crucial part is the check to avoid duplicate combinations: if `i > start_index` and `candidates[i] == candidates[i-1]`, we `continue` to the next iteration. This ensures we only start a new path with the first occurrence of a duplicate number. For each valid candidate, we add it to our current path, make a recursive call `dfs(i + 1, ..., new_target)`, and then backtrack by popping the candidate.",
                    "code": {
                        "python": "class Solution:\n    def combinationSum2(self, candidates: list[int], target: int) -> list[list[int]]:\n        candidates.sort()\n        res = []\n\n        def backtrack(cur, pos, target):\n            if target == 0:\n                res.append(cur.copy())\n            if target <= 0:\n                return\n\n            prev = -1\n            for i in range(pos, len(candidates)):\n                if candidates[i] == prev:\n                    continue\n                cur.append(candidates[i])\n                backtrack(cur, i + 1, target - candidates[i])\n                cur.pop()\n                prev = candidates[i]\n        backtrack([], 0, target)\n        return res"
                    }
                }
            },
            {
                "id": 79,
                "title": "Word Search",
                "leetcode_url": "https://leetcode.com/problems/word-search/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/word-search"
                },
                "youtube_id": "pfiQ_PS1g8E",
                "hints": [
                    "Use Depth First Search (DFS) with backtracking.",
                    "Iterate through every cell of the board. If a cell matches the first letter of the word, start a DFS from there. To avoid reusing cells, you can mark visited cells (e.g., by changing their value) and revert the change after the recursive call returns (backtracking)."
                ],
                "solution": {
                    "explanation": "We need to perform a Depth First Search (DFS) with backtracking from every cell in the grid. We start by iterating through each cell `(r, c)`. If `board[r][c]` matches the first letter of our `word`, we initiate a DFS from that cell. The DFS function takes the current position `(r, c)` and the current index `i` of the word we are trying to match. The base case for success is when `i` equals the length of the word. The base cases for failure are going out of bounds, visiting a cell that doesn't match `word[i]`, or visiting a cell that's already in our current path. To prevent reusing cells, we can temporarily modify the board at the current cell (e.g., `board[r][c] = '#'`) before making recursive calls in all four directions. After the recursive calls return, we must 'backtrack' by restoring the cell's original character.",
                    "code": {
                        "python": "class Solution:\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        path = set()\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            if (min(r, c) < 0 or r >= ROWS or c >= COLS or\n                word[i] != board[r][c] or (r, c) in path):\n                return False\n            \n            path.add((r, c))\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            path.remove((r, c))\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0): return True\n        return False"
                    }
                }
            },
            {
                "id": 131,
                "title": "Palindrome Partitioning",
                "leetcode_url": "https://leetcode.com/problems/palindrome-partitioning/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/palindrome-partitioning"
                },
                "youtube_id": "3I3l-x9E_gQ",
                "hints": [
                    "This is a backtracking problem. You need to find all possible partitions.",
                    "From the start of the string, find all possible palindromic prefixes. For each one you find, recursively run your function on the rest of the string."
                ],
                "solution": {
                    "explanation": "We can solve this using backtracking. We'll define a recursive DFS function that takes a starting index `i`. The base case is when `i` is out of bounds, which means we have successfully partitioned the entire string, so we add our current partition path to the result. In the recursive step, we loop from our start index `i` to the end of the string. In each iteration `j`, we consider the substring `s[i:j+1]`. We check if this substring is a palindrome. If it is, we add it to our current partition `part`, and then make a recursive call `dfs(j + 1)` to find partitions for the rest of the string. After the recursive call returns, we backtrack by popping the substring from our `part` to explore other possibilities.",
                    "code": {
                        "python": "class Solution:\n    def partition(self, s: str) -> list[list[str]]:\n        res = []\n        part = []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i:j+1])\n                    dfs(j + 1)\n                    part.pop()\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True"
                    }
                }
            },
            {
                "id": 51,
                "title": "N-Queens",
                "leetcode_url": "https://leetcode.com/problems/n-queens/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/n-queens"
                },
                "youtube_id": "Ph95IHm_xgc",
                "hints": [
                    "This is a classic backtracking problem.",
                    "You need to keep track of which columns, positive diagonals, and negative diagonals are occupied. A queen at `(r, c)` occupies positive diagonal `r+c` and negative diagonal `r-c`."
                ],
                "solution": {
                    "explanation": "The N-Queens puzzle is solved using backtracking. We try to place one queen per row. We define a recursive function that takes the current row `r` as a parameter. The base case is when `r == n`, which means we have successfully placed all `n` queens, so we construct the board from our state and add it to the result. In the recursive step, we iterate through each column `c` for the current row `r`. Before placing a queen, we check if the column `c`, the positive diagonal `r+c`, and the negative diagonal `r-c` are already occupied. We can use three sets to keep track of this. If the position is safe, we place the queen by adding the column and diagonals to our sets and make a recursive call for the next row, `backtrack(r + 1)`. After the call returns, we backtrack by removing the column and diagonals from our sets, effectively 'un-placing' the queen to explore other possibilities.",
                    "code": {
                        "python": "class Solution:\n    def solveNQueens(self, n: int) -> list[list[str]]:\n        col = set()\n        posDiag = set() # (r + c)\n        negDiag = set() # (r - c)\n        \n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n            \n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n                \n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res"
                    }
                }
            }
        ],
        "Graphs": [
            {
                "id": 200,
                "title": "Number of Islands",
                "leetcode_url": "https://leetcode.com/problems/number-of-islands/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/number-of-islands"
                },
                "youtube_id": "pV2kpPD66nE",
                "hints": [
                    "Iterate through every cell of the grid.",
                    "When you find a '1' that you haven't visited yet, you've found a new island. Increment your island count and then run a traversal (BFS or DFS) starting from that cell to find and 'sink' all parts of that island by marking them as visited."
                ],
                "solution": {
                    "explanation": "To count the number of islands, we can iterate through each cell of the 2D grid. We maintain a count of islands, initialized to zero. When we encounter a cell containing '1', it signifies we've found a piece of land. We increment our island count. Then, to ensure we don't count this same island again, we must find all connected parts of it and mark them as visited. This can be done with a traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS). The traversal starts from the initial '1' and explores all adjacent '1's, changing their value to something else (like '0' or '#') to mark them as visited. We continue our initial scan of the grid, and the next time we find a '1', it must belong to a new, undiscovered island.",
                    "code": {
                        "python": "from collections import deque\n\nclass Solution:\n    def numIslands(self, grid: list[list[str]]) -> int:\n        if not grid:\n            return 0\n\n        rows, cols = len(grid), len(grid[0])\n        visit = set()\n        islands = 0\n\n        def bfs(r, c):\n            q = deque()\n            visit.add((r, c))\n            q.append((r, c))\n            while q:\n                row, col = q.popleft()\n                directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n                for dr, dc in directions:\n                    r, c = row + dr, col + dc\n                    if (r in range(rows) and\n                        c in range(cols) and\n                        grid[r][c] == '1' and\n                        (r, c) not in visit):\n                        q.append((r, c))\n                        visit.add((r, c))\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    bfs(r, c)\n                    islands += 1\n        return islands"
                    }
                }
            },
            {
                "id": 133,
                "title": "Clone Graph",
                "leetcode_url": "https://leetcode.com/problems/clone-graph/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/clone-graph"
                },
                "youtube_id": "mQeF6bN8hMk",
                "hints": [
                    "You need a way to map the original nodes to their newly created copies to avoid creating duplicate nodes.",
                    "A hash map is perfect for storing the mapping `old_node -> new_node`. You can traverse the original graph using either DFS or BFS."
                ],
                "solution": {
                    "explanation": "To clone a graph, we need to traverse it while creating copies of each node and linking them correctly. A hash map is essential to store the mapping from an original node to its clone (`oldToNew`). This prevents us from re-cloning a node we've already seen. We can use a recursive DFS approach. The DFS function takes an original node as input. The base case is if the node is already in our `oldToNew` map, in which case we just return its clone from the map. If not, we create a new copy of the node, put it in the map, and then iterate through the original node's neighbors. For each neighbor, we make a recursive call to our DFS function. The result of this call is the cloned neighbor node, which we then append to the `neighbors` list of our newly created copied node.",
                    "code": {
                        "python": "# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n            \n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n        \n        return dfs(node) if node else None"
                    }
                }
            },
            {
                "id": 695,
                "title": "Max Area of Island",
                "leetcode_url": "https://leetcode.com/problems/max-area-of-island/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/max-area-of-island"
                },
                "youtube_id": "iJGr1OtmH0c",
                "hints": [
                    "This is very similar to 'Number of Islands'.",
                    "As you traverse each island, keep a count of the number of '1's that belong to it. Update a global maximum area after you've finished exploring each island."
                ],
                "solution": {
                    "explanation": "This problem builds on 'Number of Islands'. We iterate through every cell of the grid. If we find a '1', we know we've discovered a new island. We then start a traversal (DFS or BFS) from this cell to explore the entire island. During the traversal, we keep a running count of the area of the current island. Each time we visit a '1' that's part of the island, we increment the count. We must also mark visited cells (e.g., by changing '1' to '0') to avoid recounting them. After the traversal for one island is complete, we compare its area with the maximum area found so far and update it if necessary. We continue scanning the grid until all cells have been visited.",
                    "code": {
                        "python": "class Solution:\n    def maxAreaOfIsland(self, grid: list[list[str]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        maxArea = 0\n\n        def dfs(r, c):\n            if (r < 0 or r == ROWS or c < 0 or c == COLS or\n                grid[r][c] == 0 or (r,c) in visit):\n                return 0\n            \n            visit.add((r, c))\n            return (1 + dfs(r + 1, c) +\n                        dfs(r - 1, c) +\n                        dfs(r, c + 1) +\n                        dfs(r, c - 1))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 1 and (r,c) not in visit:\n                    maxArea = max(maxArea, dfs(r, c))\n        return maxArea"
                    }
                }
            },
            {
                "id": 417,
                "title": "Pacific Atlantic Water Flow",
                "leetcode_url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/pacific-atlantic-water-flow"
                },
                "youtube_id": "s-VkAiYdbes",
                "hints": [
                    "Instead of starting from a cell and trying to see if it can reach both oceans (which is complex), start from the oceans and see which cells they can reach.",
                    "Run a traversal (DFS or BFS) starting from all the cells bordering the Pacific Ocean. Mark all reachable cells. Do the same for the Atlantic Ocean. The answer is the set of cells that are reachable from both."
                ],
                "solution": {
                    "explanation": "The key insight is to work backwards from the oceans. We create two sets, `pac` and `atl`, to store the coordinates of cells that can flow to the Pacific and Atlantic oceans, respectively. We then run a DFS or BFS traversal starting from all the cells that border each ocean. For the Pacific, we start a traversal from every cell in the top row and the leftmost column. The traversal can only move from a cell to a neighbor if the neighbor's height is greater than or equal to the current cell's height (since water flows downhill). We do the same for the Atlantic, starting from the bottom and right borders. After both traversals are complete, the solution is the intersection of the `pac` and `atl` sets\u2014these are the cells that can reach both oceans.",
                    "code": {
                        "python": "class Solution:\n    def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if ((r, c) in visit or r < 0 or c < 0 or r == ROWS or c == COLS or\n                heights[r][c] < prevHeight):\n                return\n            visit.add((r,c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n        \n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n        \n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r,c) in pac and (r,c) in atl:\n                    res.append([r, c])\n        return res"
                    }
                }
            },
            {
                "id": 207,
                "title": "Course Schedule",
                "leetcode_url": "https://leetcode.com/problems/course-schedule/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/course-schedule"
                },
                "youtube_id": "EgI5nU9etnU",
                "hints": [
                    "This problem is equivalent to detecting a cycle in a directed graph.",
                    "Build an adjacency list representation of the graph. Use DFS and a set to track the nodes currently in the recursion stack (the 'visit path'). If you encounter a node that's already in the visit path during a DFS, you've found a cycle."
                ],
                "solution": {
                    "explanation": "This problem is about detecting a cycle in a directed graph where courses are nodes and prerequisites are edges. We can use Depth First Search (DFS) for cycle detection. First, we build an adjacency list from the `prerequisites` list. We also need a way to track the visited state of each node. A `visit` set can track nodes in the current recursive path. We iterate through each course from 0 to `numCourses - 1`. For each course, we run a DFS. The DFS function checks for a cycle. If it visits a node that is already in the current `visit` path, a cycle is detected, and we return `False`. If the DFS for a node completes without finding a cycle, we know that all its dependencies can be met, and we can mark it as fully processed (e.g., by adding it to a `preMap` or by clearing its prerequisites in the adjacency list) so we don't have to re-compute it again. If we finish checking all courses without finding a cycle, we return `True`.",
                    "code": {
                        "python": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        preMap = { i:[] for i in range(numCourses) }\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n        \n        visitSet = set()\n        def dfs(crs):\n            if crs in visitSet:\n                return False\n            if preMap[crs] == []:\n                return True\n            \n            visitSet.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visitSet.remove(crs)\n            preMap[crs] = []\n            return True\n        \n        for crs in range(numCourses):\n            if not dfs(crs):\n                return False\n        return True"
                    }
                }
            },
            {
                "id": 210,
                "title": "Course Schedule II",
                "leetcode_url": "https://leetcode.com/problems/course-schedule-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/course-schedule-ii"
                },
                "youtube_id": "Akt3glAwyfY",
                "hints": [
                    "This is a topological sort problem.",
                    "You can solve this with DFS. A post-order DFS traversal will naturally produce the reverse of a topological sort. You also need to detect cycles, just like in Course Schedule I."
                ],
                "solution": {
                    "explanation": "This problem asks for a topological ordering of the courses, which is possible only if there are no cycles. We can adapt the DFS cycle detection approach from Course Schedule I. We use an adjacency list and two sets: `visit` to track nodes in the current recursion path (for cycle detection) and `cycle` (or `path`) to track nodes whose descendants have been fully explored. The core of the algorithm is a DFS function. When we visit a node, we add it to the `visit` set. We then recursively visit all its neighbors. After all its neighbors have been visited and no cycle was found, we remove the node from `visit` and add it to our result list `res`. This post-order addition is what creates the topological sort. If at any point our DFS encounters a node already in `visit`, a cycle exists, and a valid order is impossible, so we return an empty list. After iterating through all courses, the `res` list will contain a valid topological order.",
                    "code": {
                        "python": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        prereq = { c:[] for c in range(numCourses) }\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n        \n        output = []\n        visit, cycle = set(), set()\n        def dfs(crs):\n            if crs in cycle:\n                return True\n            if crs in visit:\n                return False\n\n            visit.add(crs)\n            for pre in prereq[crs]:\n                if not dfs(pre):\n                    return False\n            cycle.add(crs)\n            visit.remove(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return []\n        return output"
                    }
                }
            },
            {
                "id": 684,
                "title": "Redundant Connection",
                "leetcode_url": "https://leetcode.com/problems/redundant-connection/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/redundant-connection"
                },
                "youtube_id": "FXWRE67E30M",
                "hints": [
                    "The problem asks for the last edge in the list that creates a cycle.",
                    "A Union-Find (or Disjoint Set Union) data structure is perfect for detecting cycles while building a graph edge by edge."
                ],
                "solution": {
                    "explanation": "This problem can be efficiently solved using the Union-Find data structure. We process the edges one by one. For each edge `[u, v]`, we attempt to perform a `union` operation on nodes `u` and `v`. The `union` operation merges the sets containing `u` and `v`. Before merging, the `find` operation tells us if `u` and `v` are already in the same set. If `find(u)` is the same as `find(v)`, it means there is already a path connecting `u` and `v`. Adding the current edge `[u, v]` would therefore create a cycle, making this the redundant connection. Since we process the edges in the given order, the first time we detect such a condition, we have found the answer that appears last in the input list.",
                    "code": {
                        "python": "class Solution:\n    def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            \n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]"
                    }
                }
            },
            {
                "id": 127,
                "title": "Word Ladder",
                "leetcode_url": "https://leetcode.com/problems/word-ladder/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/word-ladder"
                },
                "youtube_id": "h9iTnkgv05E",
                "hints": [
                    "This is a shortest path problem on an unweighted graph, which is a classic use case for Breadth-First Search (BFS).",
                    "The nodes of the graph are the words. An edge exists between two words if they differ by only one character. How can you efficiently find all neighbors of a word?"
                ],
                "solution": {
                    "explanation": "This problem can be modeled as finding the shortest path in an unweighted graph, so Breadth-First Search (BFS) is the ideal algorithm. The nodes are the words. To build the graph efficiently without an explicit adjacency list, we can pre-process the `wordList`. We create a map where the key is a word pattern (e.g., `h*t`) and the value is a list of words that match this pattern (`hit`, `hot`). We start a BFS by adding the `beginWord` to a queue. In each level of the BFS, we dequeue a word, generate all its possible one-letter-difference patterns, and look up these patterns in our map to find all its neighbors. For each neighbor that we haven't visited yet, we add it to the queue and our visited set. We also keep track of the distance (number of transformations). The search ends when we first encounter the `endWord`.",
                    "code": {
                        "python": "from collections import deque, defaultdict\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        nei = defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j+1:]\n                nei[pattern].append(word)\n        \n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j+1:]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0"
                    }
                }
            },
            {
                "id": 323,
                "title": "Number of Connected Components in an Undirected Graph",
                "leetcode_url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
                "solution_link": {
                    "text": "NeetCode Video",
                    "url": "https://www.youtube.com/watch?v=8f1A64_R_us"
                },
                "youtube_id": "8f1A64_R_us",
                "hints": [
                    "This is a classic graph traversal problem.",
                    "Iterate through all the nodes from 0 to n-1. Keep a `visited` set. If a node has not been visited, you've found a new component. Increment your component counter and start a traversal (DFS or BFS) from this node to mark every node in its component as visited."
                ],
                "solution": {
                    "explanation": "To find the number of connected components, we can build an adjacency list representation of the graph. Then, we iterate through all the nodes. We use a `visited` set to keep track of nodes we've already accounted for. For each node `i` from 0 to `n-1`, if `i` is not in our `visited` set, it means we have discovered a new, previously unseen component. We increment our component counter. Then, we start a graph traversal (like DFS or BFS) from node `i`. This traversal will visit all the nodes connected to `i` and add them to the `visited` set. After the traversal is complete, we continue our main loop. The final value of our counter is the answer.",
                    "code": {
                        "python": "class Solution:\n    def countComponents(self, n: int, edges: list[list[int]]) -> int:\n        adj = { i:[] for i in range(n) }\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n        \n        visit = set()\n        count = 0\n        def dfs(i):\n            if i in visit:\n                return\n            visit.add(i)\n            for neighbor in adj[i]:\n                dfs(neighbor)\n\n        for i in range(n):\n            if i not in visit:\n                count += 1\n                dfs(i)\n        return count"
                    }
                }
            },
            {
                "id": 261,
                "title": "Graph Valid Tree",
                "leetcode_url": "https://leetcode.com/problems/graph-valid-tree/",
                "solution_link": {
                    "text": "NeetCode Video",
                    "url": "https://www.youtube.com/watch?v=bXsUuownnoQ"
                },
                "youtube_id": "bXsUuownnoQ",
                "hints": [
                    "A graph is a valid tree if and only if two conditions are met: it has no cycles, and it is fully connected.",
                    "For a graph with `n` nodes to be a tree, it must have exactly `n-1` edges. After checking this, you just need to detect a cycle."
                ],
                "solution": {
                    "explanation": "A graph is a valid tree if it's connected and has no cycles. An important property is that a connected graph with `n` nodes has exactly `n-1` edges if and only if it's a tree. So, we can first check if `len(edges) == n - 1`. If not, it can't be a tree. If this condition holds, we just need to verify that the graph is fully connected (or, equivalently, that it has no cycles, as the edge count condition implies one if the other is true). We can do this by performing a single traversal (DFS or BFS) starting from an arbitrary node (e.g., node 0). After the traversal, we check if the number of visited nodes is equal to `n`. If it is, the graph is fully connected and therefore a valid tree.",
                    "code": {
                        "python": "class Solution:\n    def validTree(self, n: int, edges: list[list[int]]) -> bool:\n        if not n:\n            return True\n        if len(edges) != n - 1:\n            return False\n\n        adj = { i:[] for i in range(n) }\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n        def dfs(i, prev):\n            if i in visit:\n                return False\n            \n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)"
                    }
                }
            },
            {
                "id": 332,
                "title": "Reconstruct Itinerary",
                "leetcode_url": "https://leetcode.com/problems/reconstruct-itinerary/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reconstruct-itinerary"
                },
                "youtube_id": "4psfQGC3b6U",
                "hints": [
                    "This is a problem of finding an Eulerian path. The path must use every edge exactly once.",
                    "Use DFS. To get the lexicographically smallest path, sort the destinations from each airport. When you are at an airport, recursively visit the smallest unvisited destination. Add an airport to the final path only after all its outgoing flights have been used."
                ],
                "solution": {
                    "explanation": "This problem asks for an Eulerian path through the graph of flights. Hierholzer's algorithm, implemented with DFS, is a perfect fit. First, we build an adjacency list, making sure to sort the destinations for each airport lexicographically. This ensures that we always try the smallest lexical destination first. We then perform a post-order DFS. The core idea is that we only add an airport to our final `route` after we have visited all of its available destinations. We can use a stack for the traversal. Starting with 'JFK', we explore its destinations. A destination is only added to the final `route` once we can't go any further from it. This means the end of the path is added first. We build the route backwards, prepending the airports as we pop them from our recursion stack.",
                    "code": {
                        "python": "from collections import defaultdict\n\nclass Solution:\n    def findItinerary(self, tickets: list[list[str]]) -> list[str]:\n        adj = defaultdict(list)\n        for src, dst in sorted(tickets, reverse=True):\n            adj[src].append(dst)\n        \n        route = []\n        stack = ['JFK']\n        while stack:\n            while adj[stack[-1]]:\n                stack.append(adj[stack[-1]].pop())\n            route.append(stack.pop())\n        \n        return route[::-1]"
                    }
                }
            }
        ],
        "Advanced Graphs": [
            {
                "id": 1584,
                "title": "Min Cost to Connect All Points",
                "leetcode_url": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/min-cost-to-connect-all-points"
                },
                "youtube_id": "f7JOBJIC-NA",
                "hints": [
                    "The problem is asking for a Minimum Spanning Tree (MST) of a graph where the points are vertices and the Manhattan distance between points are the edge weights.",
                    "Prim's algorithm is a great fit. Start with one node, and use a min-heap to greedily add the cheapest edge connecting a visited node to an unvisited node."
                ],
                "solution": {
                    "explanation": "This problem is a classic application of finding a Minimum Spanning Tree (MST). We can use Prim's algorithm. First, we build an adjacency list where each entry stores the neighbors of a node and the Manhattan distance to them. We start the algorithm from an arbitrary point (e.g., index 0). We use a min-heap to store potential edges to add to our MST, prioritized by cost (distance). Initially, it contains the edges from our starting point. We also need a `visit` set to track nodes already in our MST. We loop until we've added `N-1` edges (where N is the number of points). In each step, we pop the edge with the minimum cost from the heap. If the destination node of this edge is already visited, we skip it. Otherwise, we add the edge's cost to our total, mark the destination node as visited, and add all of its outgoing edges to unvisited nodes into the min-heap.",
                    "code": {
                        "python": "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: list[list[int]]) -> int:\n        N = len(points)\n        adj = { i:[] for i in range(N) }\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n        \n        # Prim's Algorithm\n        res = 0\n        visit = set()\n        minH = [[0, 0]] # [cost, point]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res"
                    }
                }
            },
            {
                "id": 778,
                "title": "Swim in Rising Water",
                "leetcode_url": "https://leetcode.com/problems/swim-in-rising-water/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/swim-in-rising-water"
                },
                "youtube_id": "amvrKlMLuG4",
                "hints": [
                    "Think of this as finding a path from (0, 0) to (n-1, n-1) with the minimum possible 'bottleneck'. The bottleneck of a path is the highest elevation encountered on that path.",
                    "This is a variation of Dijkstra's shortest path algorithm. Use a min-heap to prioritize visiting cells with lower elevations first."
                ],
                "solution": {
                    "explanation": "This problem can be solved using a modification of Dijkstra's algorithm to find the path with the minimum required 'effort'. The 'effort' or 'cost' of a path is defined by the maximum elevation along that path. We use a min-heap to explore the grid, storing tuples of `(max_height_on_path, row, col)`. We start by pushing the top-left cell `(grid[0][0], 0, 0)` into the heap. We also use a `visit` set to avoid cycles. At each step, we pop the cell with the minimum maximum-height from the heap. This `max_height` is our current time `t`. If this cell is the bottom-right corner, we have found our answer. If not, we explore its four neighbors. For each neighbor, the new path's maximum height will be `max(t, neighbor_height)`. We push this new `(new_max_height, new_row, new_col)` tuple into the heap if the neighbor has not been visited.",
                    "code": {
                        "python": "import heapq\n\nclass Solution:\n    def swimInWater(self, grid: list[list[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]] # (time, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n\n            if r == N - 1 and c == N - 1:\n                return t\n            \n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (neiR < 0 or neiC < 0 or\n                    neiR == N or neiC == N or\n                    (neiR, neiC) in visit):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])"
                    }
                }
            },
            {
                "id": 743,
                "title": "Network Delay Time",
                "leetcode_url": "https://leetcode.com/problems/network-delay-time/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/network-delay-time"
                },
                "youtube_id": "EaphyqKU4PQ",
                "hints": [
                    "This is a classic single-source shortest path problem on a weighted, directed graph.",
                    "Dijkstra's algorithm is the perfect fit. Use a min-heap to always explore the node that is currently reachable in the shortest amount of time."
                ],
                "solution": {
                    "explanation": "To find the time it takes for a signal to reach all nodes, we need to find the shortest path from the starting node `k` to all other nodes. The answer will be the longest of these shortest paths. Dijkstra's algorithm is ideal for this. We start by building an adjacency list from the `times` input. We use a min-heap to store `(time, node)` tuples, prioritizing smaller times. We also use a `visit` set to track nodes for which we have already found the shortest path. We start with `(0, k)` in the heap. In a loop, we pop the node with the minimum time. If it's already visited, we skip it. Otherwise, we add it to `visit`, add its time to our total time, and then iterate through its neighbors, adding them to the heap with their updated travel times (`current_time + edge_weight`). The final answer is the time associated with the last node to be visited. If the number of visited nodes is less than `n`, some nodes are unreachable, and we return -1.",
                    "code": {
                        "python": "import heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n        edges = defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n        \n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = max(t, w1)\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1"
                    }
                }
            },
            {
                "id": 787,
                "title": "Cheapest Flights Within K Stops",
                "leetcode_url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/cheapest-flights-within-k-stops"
                },
                "youtube_id": "5eIK3zUdYmE",
                "hints": [
                    "This is a shortest path problem with an additional constraint on the number of stops.",
                    "A standard Dijkstra's won't work correctly. The Bellman-Ford algorithm is a better fit as it can be easily adapted to handle the stop limit."
                ],
                "solution": {
                    "explanation": "This problem can be solved using a modified Bellman-Ford algorithm. Bellman-Ford is used to find shortest paths from a single source, and its structure is well-suited for the 'k stops' constraint. We maintain an array `prices` to store the minimum cost to reach each city, initialized to infinity except for the `src` city which is 0. We then relax the edges repeatedly. The key is that we run the main relaxation loop exactly `k+1` times. Each iteration `i` of the loop finds the cheapest price to all nodes using at most `i` edges (stops). Inside the loop, we iterate through all flights `(u, v, price)` and update the cost to `v` if `prices[u] + price` is cheaper than the current `prices[v]`. We must use a temporary copy of the `prices` array in each iteration to ensure that the paths we find in iteration `i` are strictly of length `i`. After `k+1` iterations, `prices[dst]` will hold the cheapest price with at most `k` stops.",
                    "code": {
                        "python": "class Solution:\n    def findCheapestPrice(self, n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:\n                if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        \n        return -1 if prices[dst] == float(\"inf\") else prices[dst]"
                    }
                }
            },
            {
                "id": 1976,
                "title": "Number of Ways to Arrive at Destination",
                "leetcode_url": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/1417576/python-dijkstra-s-algorithm-detailed-explanation/"
                },
                "youtube_id": "Jtr31h5z99I",
                "hints": [
                    "This is a shortest path problem with an added twist of counting the number of such paths.",
                    "You need to modify Dijkstra's algorithm. In addition to storing the minimum distance to a node, you also need to store the number of ways to achieve that minimum distance."
                ],
                "solution": {
                    "explanation": "This problem requires a modification of Dijkstra's algorithm. We need to track two things for each node: the minimum time to reach it (`dist`) and the number of ways to do so (`ways`). We initialize `dist` with infinity and `ways` with 0 for all nodes, except the starting node 0 (`dist[0] = 0, ways[0] = 1`). We use a min-heap storing `(time, node)` to explore the graph. When we extract a node `u` from the heap, we explore its neighbors `v`. If we find a path to `v` that is strictly shorter than `dist[v]`, we've found a new best path. We update `dist[v]` with the new shorter time and set `ways[v]` equal to `ways[u]`. If we find a path to `v` that has the exact same time as `dist[v]`, we've found another shortest path. We don't update `dist[v]`, but we increment `ways[v]` by `ways[u]`. The final answer is the number of ways to reach the destination node `n-1`.",
                    "code": {
                        "python": "import heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def countPaths(self, n: int, roads: list[list[int]]) -> int:\n        adj = defaultdict(list)\n        for u, v, t in roads:\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n\n        dist = [float('inf')] * n\n        ways = [0] * n\n        dist[0] = 0\n        ways[0] = 1\n        mod = 10**9 + 7\n\n        minHeap = [(0, 0)] # (time, node)\n\n        while minHeap:\n            d, u = heapq.heappop(minHeap)\n\n            if d > dist[u]:\n                continue\n\n            for v, t in adj[u]:\n                if dist[u] + t < dist[v]:\n                    dist[v] = dist[u] + t\n                    ways[v] = ways[u]\n                    heapq.heappush(minHeap, (dist[v], v))\n                elif dist[u] + t == dist[v]:\n                    ways[v] = (ways[v] + ways[u]) % mod\n        \n        return ways[n-1]"
                    }
                }
            }
        ],
        "1-D Dynamic Programming": [
            {
                "id": 70,
                "title": "Climbing Stairs",
                "leetcode_url": "https://leetcode.com/problems/climbing-stairs/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/climbing-stairs"
                },
                "youtube_id": "Y0lT9Fck7qI",
                "hints": [
                    "To reach step `n`, you could have come from either step `n-1` or step `n-2`.",
                    "This problem is a Fibonacci sequence in disguise. The number of ways to reach step `n` is `ways(n-1) + ways(n-2)`."
                ],
                "solution": {
                    "explanation": "This is a classic dynamic programming problem. The number of distinct ways to reach the `n`-th step is the sum of the ways to reach the `(n-1)`-th step and the ways to reach the `(n-2)`-th step. This forms a Fibonacci-like sequence. We can solve this with a bottom-up DP approach using constant space. We only need to keep track of the number of ways for the previous two steps. Let's call them `one` (for `n-1`) and `two` (for `n-2`). We initialize `one = 1` and `two = 1`. We then loop from `n-2` down to 0. In each iteration, we calculate the ways for the current step `temp = one + two`, then shift our pointers: `two` becomes `one`, and `one` becomes `temp`. After the loop, `one` will hold the total number of ways to reach the top.",
                    "code": {
                        "python": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        one, two = 1, 1\n        for i in range(n - 1):\n            temp = one\n            one = one + two\n            two = temp\n        return one"
                    }
                }
            },
            {
                "id": 198,
                "title": "House Robber",
                "leetcode_url": "https://leetcode.com/problems/house-robber/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/house-robber"
                },
                "youtube_id": "73r3KWiEvyk",
                "hints": [
                    "For each house, you have two choices: either rob it or don't rob it.",
                    "If you rob house `i`, you cannot rob house `i-1`. If you don't rob house `i`, your maximum profit is the same as the maximum profit up to house `i-1`. The decision is `max(rob_i + profit_at_i-2, profit_at_i-1)`."
                ],
                "solution": {
                    "explanation": "This is a dynamic programming problem. For each house, we want to determine the maximum amount of money we can rob up to that point. Let's consider house `i`. We have two choices: 1. Don't rob house `i`. In this case, our maximum profit is whatever the maximum profit was from robbing the previous houses (up to `i-1`). 2. Rob house `i`. In this case, we get the money from `nums[i]`, but we cannot have robbed house `i-1`. So, our profit would be `nums[i]` plus the maximum profit from robbing houses up to `i-2`. We can solve this with a bottom-up approach using two variables to store the maximum profit from the last two considerations, effectively `rob1` and `rob2`. As we iterate through the `nums` array, the new maximum is `max(n + rob1, rob2)`, where `n` is the current house's money.",
                    "code": {
                        "python": "class Solution:\n    def rob(self, nums: list[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        # [rob1, rob2, n, n+1, ...]\n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2"
                    }
                }
            },
            {
                "id": 213,
                "title": "House Robber II",
                "leetcode_url": "https://leetcode.com/problems/house-robber-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/house-robber-ii"
                },
                "youtube_id": "rC5CEkUaGgk",
                "hints": [
                    "The only difference from House Robber I is that the first and last houses are now considered adjacent.",
                    "This means you can either rob the first house and not the last, OR rob the last house and not the first. You can't do both. Solve the original House Robber problem on two separate subarrays to represent these two scenarios."
                ],
                "solution": {
                    "explanation": "The circular arrangement means the first and last houses are neighbors. This implies we can never rob both the first and the last house. This constraint breaks the problem down into two separate subproblems: 1. What is the maximum profit if we rob from the houses in the range `[0, n-2]` (i.e., we include the first house but exclude the last)? 2. What is the maximum profit if we rob from the houses in the range `[1, n-1]` (i.e., we exclude the first house but include the last)? We can solve both of these subproblems using the exact same logic from the original House Robber problem. The final answer will be the maximum of the results from these two scenarios. We also need to handle the edge case of a single house.",
                    "code": {
                        "python": "class Solution:\n    def rob(self, nums: list[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n\n        return max(self.helper(nums[:-1]), self.helper(nums[1:]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n        for n in nums:\n            newRob = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2"
                    }
                }
            },
            {
                "id": 322,
                "title": "Coin Change",
                "leetcode_url": "https://leetcode.com/problems/coin-change/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/coin-change"
                },
                "youtube_id": "H9bfqozjoqs",
                "hints": [
                    "This is a classic dynamic programming problem.",
                    "Let `dp[i]` be the minimum number of coins to make amount `i`. The recurrence relation is `dp[i] = 1 + min(dp[i - c])` for all coins `c`."
                ],
                "solution": {
                    "explanation": "We can solve this using bottom-up dynamic programming. We create a DP array, `dp`, of size `amount + 1`, where `dp[a]` will store the minimum number of coins needed to make up amount `a`. We initialize the array with a large value (like `amount + 1` to represent infinity) and set `dp[0] = 0`, since 0 coins are needed for an amount of 0. We then iterate through each amount `a` from 1 to `amount`. For each amount `a`, we iterate through our available `coins`. If a coin `c` is less than or equal to `a`, we can potentially use it. The number of coins required would be `1 + dp[a - c]`. We want the minimum, so we update `dp[a]` with `min(dp[a], 1 + dp[a - c])`. After filling the entire DP array, `dp[amount]` will hold our answer. If it's still the large initial value, the amount is impossible to make.",
                    "code": {
                        "python": "class Solution:\n    def coinChange(self, coins: list[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        \n        return dp[amount] if dp[amount] != amount + 1 else -1"
                    }
                }
            },
            {
                "id": 300,
                "title": "Longest Increasing Subsequence",
                "leetcode_url": "https://leetcode.com/problems/longest-increasing-subsequence/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-increasing-subsequence"
                },
                "youtube_id": "cjWnW0hdF1Y",
                "hints": [
                    "A classic DP solution involves an O(n^2) approach where `dp[i]` is the length of the LIS ending at index `i`.",
                    "A more clever O(n log n) solution exists. It involves maintaining a sorted list of the smallest tail of all increasing subsequences of various lengths."
                ],
                "solution": {
                    "explanation": "A very clever O(n log n) solution exists for this problem. We maintain an array (let's call it `sub`) which stores the smallest tail of all increasing subsequences with length `i+1`. We iterate through the input `nums`. For each number `n`, we try to place it into our `sub` array. If `n` is greater than all elements in `sub`, it means we can extend the longest subsequence found so far, so we append `n` to `sub`. If `n` is not greater than all elements, it means it can potentially be a new, smaller tail for an existing subsequence length, making it possible to build future subsequences more easily. We find the first element in `sub` that is greater than or equal to `n` and replace it with `n`. This can be done efficiently with a binary search. The final answer is the length of this `sub` array.",
                    "code": {
                        "python": "class Solution:\n    def lengthOfLIS(self, nums: list[int]) -> int:\n        tails = []\n        for num in nums:\n            if not tails or num > tails[-1]:\n                tails.append(num)\n            else:\n                l, r = 0, len(tails) - 1\n                while l <= r:\n                    m = (l + r) // 2\n                    if tails[m] < num:\n                        l = m + 1\n                    else:\n                        r = m - 1\n                tails[l] = num\n        return len(tails)"
                    }
                }
            },
            {
                "id": 139,
                "title": "Word Break",
                "leetcode_url": "https://leetcode.com/problems/word-break/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/word-break"
                },
                "youtube_id": "Sx9NNgInc3A",
                "hints": [
                    "This is a dynamic programming problem.",
                    "Let `dp[i]` be a boolean indicating whether the substring `s[0...i-1]` can be segmented. To compute `dp[i]`, you need to check if there's a `j < i` such that `dp[j]` is true and the substring `s[j...i-1]` is a word in the dictionary."
                ],
                "solution": {
                    "explanation": "We can solve this using bottom-up dynamic programming. We create a DP array, `dp`, of size `len(s) + 1`, where `dp[i]` represents whether the prefix of `s` of length `i` can be segmented. We initialize `dp[0] = True` because an empty string can always be formed. We then iterate from `i = 1` to `len(s)`. For each `i`, we iterate backwards from `j = i - 1` to 0. In this inner loop, we consider the substring `s[j:i]`. If `dp[j]` is `True` (meaning the prefix `s[0:j]` can be formed) AND the substring `s[j:i]` is in our `wordDict`, it means we can successfully form the prefix `s[0:i]`. So, we set `dp[i] = True` and can break the inner loop. The final answer is the value of `dp[len(s)]`.",
                    "code": {
                        "python": "class Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"
                    }
                }
            },
            {
                "id": 416,
                "title": "Partition Equal Subset Sum",
                "leetcode_url": "https://leetcode.com/problems/partition-equal-subset-sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/partition-equal-subset-sum"
                },
                "youtube_id": "IsvocB5BJhw"
            },
            {
                "id": 5,
                "title": "Longest Palindromic Substring",
                "leetcode_url": "https://leetcode.com/problems/longest-palindromic-substring/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-palindromic-substring"
                },
                "youtube_id": "XYQe_k-Zph0"
            },
            {
                "id": 647,
                "title": "Palindromic Substrings",
                "leetcode_url": "https://leetcode.com/problems/palindromic-substrings/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/palindromic-substrings"
                },
                "youtube_id": "4RACzI5-du8"
            },
            {
                "id": 91,
                "title": "Decode Ways",
                "leetcode_url": "https://leetcode.com/problems/decode-ways/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/decode-ways"
                },
                "youtube_id": "6aEyTjOwlJU"
            }
        ],
        "2-D Dynamic Programming": [
            {
                "id": 62,
                "title": "Unique Paths",
                "leetcode_url": "https://leetcode.com/problems/unique-paths/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/unique-paths"
                },
                "youtube_id": "Jz4_nC_fK_0",
                "hints": [
                    "This is a dynamic programming problem.",
                    "The number of ways to get to a cell `(r, c)` is the sum of the ways to get to the cell above it `(r-1, c)` and the ways to get to the cell to its left `(r, c-1)`."
                ],
                "solution": {
                    "explanation": "This can be solved with a bottom-up DP approach. The number of unique paths to reach any cell `(r, c)` is the sum of the unique paths to reach the cell directly above it and the cell directly to its left. We can optimize the space by using only a single row for our DP table. We initialize a row of size `n` with all 1s, because there's only one way to reach any cell in the first row. Then, we iterate for each remaining row (from the second row to row `m-1`). For each cell in the current row being computed, its new value is the sum of its previous value (paths from the top) and the value of the cell to its left in the *newly updated* row (paths from the left). After iterating through all the rows, the last element of our DP row will be the answer.",
                    "code": {
                        "python": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j+1] + row[j]\n            row = newRow\n        return row[0]"
                    }
                }
            },
            {
                "id": 1143,
                "title": "Longest Common Subsequence",
                "leetcode_url": "https://leetcode.com/problems/longest-common-subsequence/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-common-subsequence"
                },
                "youtube_id": "Ua0GhsJslWM",
                "hints": [
                    "This is a classic 2D dynamic programming problem.",
                    "Let `dp[i][j]` be the length of the LCS of `text1[0...i-1]` and `text2[0...j-1]`. If `text1[i-1] == text2[j-1]`, then `dp[i][j] = 1 + dp[i-1][j-1]`. Otherwise, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`."
                ],
                "solution": {
                    "explanation": "We can solve this using bottom-up 2D dynamic programming. We create a DP grid of size `(len(text1)+1) x (len(text2)+1)`. `dp[i][j]` will store the length of the longest common subsequence between the prefixes `text1[:i]` and `text2[:j]`. We iterate through the grid. For each cell `(i, j)`, we compare `text1[i-1]` and `text2[j-1]`. If the characters are the same, it means they can extend the common subsequence, so `dp[i][j] = 1 + dp[i-1][j-1]`. If they are different, we can't extend the subsequence with both characters, so we must take the best result from the previous states, which is `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`. The final answer will be in the bottom-right cell of the grid, `dp[len(text1)][len(text2)]`. We can optimize space to O(n) by only keeping track of the previous and current DP rows.",
                    "code": {
                        "python": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]\n\n        for i in range(len(text1) -1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 + dp[i+1][j+1]\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j+1])\n        return dp[0][0]"
                    }
                }
            },
            {
                "id": 72,
                "title": "Edit Distance",
                "leetcode_url": "https://leetcode.com/problems/edit-distance/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/edit-distance"
                },
                "youtube_id": "XYi2-Lprwm4",
                "hints": [
                    "This is a classic 2D dynamic programming problem.",
                    "Let `dp[i][j]` be the minimum number of operations to convert `word1[0...i-1]` to `word2[0...j-1]`. Consider the three possible operations (insert, delete, replace) to find the recurrence relation."
                ],
                "solution": {
                    "explanation": "To find the minimum edit distance, we use 2D dynamic programming. We create a DP grid `dp` where `dp[i][j]` is the minimum cost to convert the prefix `word1[:i]` to `word2[:j]`. The base cases are the first row and column, which represent the cost of converting a prefix to an empty string (by deletion) or an empty string to a prefix (by insertion). We then iterate through the rest of the grid. For any cell `dp[i][j]`, if the characters `word1[i-1]` and `word2[j-1]` are the same, no operation is needed, so `dp[i][j] = dp[i-1][j-1]`. If they are different, we must perform an operation. We take the minimum of the three possible actions: 1. Replace (`dp[i-1][j-1] + 1`), 2. Delete (`dp[i-1][j] + 1`), 3. Insert (`dp[i][j-1] + 1`). The final answer is in the bottom-right cell `dp[len(word1)][len(word2)]`.",
                    "code": {
                        "python": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i+1][j+1]\n                else:\n                    dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1])\n        return dp[0][0]"
                    }
                }
            },
            {
                "id": 309,
                "title": "Best Time to Buy and Sell Stock with Cooldown",
                "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/best-time-to-buy-and-sell-stock-with-cooldown"
                },
                "youtube_id": "I7j0F7AHfGY",
                "hints": [
                    "This requires tracking multiple states for each day.",
                    "For any given day, you can be in one of three states: holding a stock ('buying' state), not holding a stock after selling ('selling' state), or not holding a stock and being able to buy ('cooldown' or 'resting' state)."
                ],
                "solution": {
                    "explanation": "This problem can be modeled using a state machine approach with dynamic programming or, more simply, through decision-making at each step. For every day, we need to decide the maximum profit we can have by taking one of three actions: Buy, Sell, or Cooldown. Let's track the max profit in two states: `buying` (max profit if we end the day holding a stock) and `selling` (max profit if we end the day not holding a stock). For each day `p` in prices: \n1. The new `buying` state could be either continuing to hold from yesterday (`buying`) or buying today. If we buy today, we must have been in a cooldown state yesterday, so the profit is `cooldown - p`. We take the max. \n2. The new `selling` state is a result of selling today, so the profit is `buying + p`. \nWe also need a `cooldown` variable that tracks the profit from the previous `selling` state. We update these states iteratively and the final answer is the max profit in the `selling` state after all days.",
                    "code": {
                        "python": "class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        # State: Buying, Selling\n        # Buying: Max profit if I have a stock at the end of the day\n        # Selling: Max profit if I don't have a stock at the end of the day\n\n        buying, selling = -prices[0], 0\n        cooldown = 0\n\n        for i in range(1, len(prices)):\n            prev_buying = buying\n            buying = max(buying, cooldown - prices[i])\n            cooldown = max(cooldown, selling)\n            selling = prev_buying + prices[i]\n        return max(buying, selling, cooldown)"
                    }
                }
            },
            {
                "id": 518,
                "title": "Coin Change II",
                "leetcode_url": "https://leetcode.com/problems/coin-change-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/coin-change-ii"
                },
                "youtube_id": "Mjy4hd2xgrs",
                "hints": [
                    "This is an 'unbounded knapsack' type of dynamic programming problem.",
                    "Let `dp[i]` be the number of ways to make up amount `i`. For each coin `c`, iterate through the amounts `j` from `c` to `amount`, and update `dp[j]` by adding `dp[j-c]` to it."
                ],
                "solution": {
                    "explanation": "This problem asks for the number of combinations, which can be solved with dynamic programming. We can use a 1D DP array, `dp`, of size `amount + 1`, where `dp[a]` stores the number of ways to make change for amount `a`. We initialize `dp[0] = 1` (there is one way to make amount 0: by using no coins). We then iterate through each `coin` in our `coins` list. For each coin, we perform an inner loop, iterating through amounts `a` from `1` to `amount`. If the current amount `a` is greater than or equal to the `coin`, it means we can form amount `a` by adding the current `coin` to any combination that formed `a - coin`. So, we update `dp[a] = dp[a] + dp[a - coin]`. By structuring the loops this way (outer loop for coins, inner for amounts), we ensure we are counting combinations, not permutations. The final answer is `dp[amount]`.",
                    "code": {
                        "python": "class Solution:\n    def change(self, amount: int, coins: list[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a-coins[i]]\n            dp = nextDP\n        return dp[amount]"
                    }
                }
            },
            {
                "id": 494,
                "title": "Target Sum",
                "leetcode_url": "https://leetcode.com/problems/target-sum/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/target-sum"
                },
                "youtube_id": "g0npyaQtAQM",
                "hints": [
                    "This is a backtracking or DP problem.",
                    "Let `dp[i][total]` be the number of ways to get a sum of `total` using the first `i` numbers. The state transitions would be `dp[i-1][total - nums[i]]` and `dp[i-1][total + nums[i]]`."
                ],
                "solution": {
                    "explanation": "This can be solved using dynamic programming with memoization. We can define a recursive backtracking function that explores all possible combinations of plus and minus signs. The function `backtrack(i, total)` will calculate the number of ways to reach the target sum starting from index `i` with the current `total`. The base case is when we've processed all numbers (`i == len(nums)`). If the `total` at this point equals the `target`, we return 1, otherwise 0. In the recursive step, we explore both possibilities for the number `nums[i]`: adding it (`backtrack(i + 1, total + nums[i])`) and subtracting it (`backtrack(i + 1, total - nums[i])`). The result for the current state is the sum of these two recursive calls. To avoid re-computing results for the same state `(i, total)`, we use a hash map as a memoization cache.",
                    "code": {
                        "python": "class Solution:\n    def findTargetSumWays(self, nums: list[int], target: int) -> int:\n        dp = {} # (index, total) -> # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n            \n            dp[(i, total)] = (backtrack(i + 1, total + nums[i]) +\n                              backtrack(i + 1, total - nums[i]))\n            return dp[(i, total)]\n\n        return backtrack(0, 0)"
                    }
                }
            },
            {
                "id": 10,
                "title": "Regular Expression Matching",
                "leetcode_url": "https://leetcode.com/problems/regular-expression-matching/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/regular-expression-matching"
                },
                "youtube_id": "HAA8mgxlov8",
                "hints": [
                    "This is a very hard dynamic programming or recursion problem.",
                    "The state needs to be defined by two pointers, `i` for the string and `j` for the pattern. The key is how to handle the `*` character. It can mean zero occurrences or one or more occurrences of the preceding character."
                ],
                "solution": {
                    "explanation": "This can be solved with 2D dynamic programming or recursion with memoization. Let's define a function `dfs(i, j)` that returns true if the substring `s[i:]` matches the sub-pattern `p[j:]`. The base cases are when we've exhausted the pattern or the string. The main logic revolves around the `*` character. If `p[j+1]` is `*`, we have two choices: 1. We don't use the `*` and its preceding character at all, so we check if `dfs(i, j + 2)` is a match. 2. We use the `*`. This is only possible if the current characters match (`s[i]` and `p[j]`, or `p[j]` is '.'). If they match, we move to the next character in the string but stay at the same pattern position, checking `dfs(i + 1, j)`. If `p[j+1]` is not `*`, we just need a simple character match and then we advance both pointers, checking `dfs(i + 1, j + 1)`. Memoization on the state `(i, j)` is crucial to avoid re-computation.",
                    "code": {
                        "python": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache = {}\n\n        def dfs(i, j):\n            if (i, j) in cache:\n                return cache[(i, j)]\n            if i >= len(s) and j >= len(p):\n                return True\n            if j >= len(p):\n                return False\n\n            match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n            if (j + 1) < len(p) and p[j+1] == \"*\":\n                cache[(i,j)] = (dfs(i, j + 2) or       # don't use *\n                                (match and dfs(i + 1, j))) # use *\n                return cache[(i,j)]\n            \n            if match:\n                cache[(i,j)] = dfs(i + 1, j + 1)\n                return cache[(i,j)]\n            \n            cache[(i,j)] = False\n            return False\n        \n        return dfs(0, 0)"
                    }
                }
            },
            {
                "id": 44,
                "title": "Wildcard Matching",
                "leetcode_url": "https://leetcode.com/problems/wildcard-matching/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/wildcard-matching"
                },
                "youtube_id": "NPr9o2odG8A",
                "hints": [
                    "This is similar to 'Regular Expression Matching' and can be solved with 2D DP.",
                    "The `*` wildcard is the tricky part. It can match any sequence of characters (including an empty sequence). This means if `p[j]` is `*`, you can either ignore it and match `s` with `p[j+1]`, or match one character of `s` with `*` and continue matching `s[i+1]` with `p[j]`."
                ],
                "solution": {
                    "explanation": "This problem can be solved using 2D dynamic programming. We create a DP table `dp` where `dp[i][j]` is a boolean indicating if the first `i` characters of `s` match the first `j` characters of `p`. We iterate through the string and pattern. If `s[i-1] == p[j-1]` or `p[j-1] == '?'`, the match depends on the previous state `dp[i-1][j-1]`. If `p[j-1] == '*'`, it can match an empty sequence (in which case `dp[i][j]` depends on `dp[i][j-1]`) or it can match one or more characters (in which case `dp[i][j]` depends on `dp[i-1][j]`). The base case `dp[0][0]` is `True`. We also need to handle leading `*`s in the pattern, which can match an empty string.",
                    "code": {
                        "python": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        dp[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \"?\")\n\n                if p[j] == \"*\":\n                    dp[i][j] = dp[i][j+1] or (i < len(s) and dp[i+1][j])\n                elif match:\n                    dp[i][j] = dp[i+1][j+1]\n        return dp[0][0]"
                    }
                }
            },
            {
                "id": 887,
                "title": "Super Egg Drop",
                "leetcode_url": "https://leetcode.com/problems/super-egg-drop/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/super-egg-drop"
                },
                "youtube_id": "2z-A2T-1uhc",
                "hints": [
                    "This is a very challenging dynamic programming problem.",
                    "Let `dp[k][m]` be the maximum number of floors you can check with `k` eggs and `m` moves. `dp[k][m] = 1 + dp[k-1][m-1] + dp[k][m-1]`. The first term is the floor you drop from, the second is if it breaks, the third is if it doesn't."
                ],
                "solution": {
                    "explanation": "Instead of asking 'what is the minimum moves for K eggs and N floors', the DP state is more intuitive if we ask 'what is the maximum number of floors we can check given K eggs and M moves?'. Let `dp[m][k]` be this maximum number of floors. If we make a move from some floor, the egg either breaks or it doesn't. If it breaks, we have `k-1` eggs and `m-1` moves left, allowing us to check `dp[m-1][k-1]` floors below. If it doesn't break, we have `k` eggs and `m-1` moves left, allowing us to check `dp[m-1][k]` floors above. So, `dp[m][k] = 1 (current floor) + dp[m-1][k-1] + dp[m-1][k]`. We can build this DP table and find the first number of moves `m` for which `dp[m][K] >= N`.",
                    "code": {
                        "python": "class Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        dp = [[0] * (k + 1) for i in range(n + 1)]\n        for m in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[m][j] = 1 + dp[m-1][j-1] + dp[m-1][j]\n            if dp[m][k] >= n:\n                return m\n        return n"
                    }
                }
            },
            {
                "id": 132,
                "title": "Palindrome Partitioning II",
                "leetcode_url": "https://leetcode.com/problems/palindrome-partitioning-ii/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/133320/python-dp-solution/"
                },
                "youtube_id": "lU4-jak_A4k",
                "hints": [
                    "This is a dynamic programming problem. Let `dp[i]` be the minimum number of cuts needed for the substring `s[:i]`.",
                    "You'll likely need another DP table to pre-calculate whether any given substring `s[j:i]` is a palindrome to avoid re-computing it every time."
                ],
                "solution": {
                    "explanation": "This problem asks for the minimum cuts, which suggests a dynamic programming approach. Let `cuts[i]` be the minimum number of cuts for the prefix `s[:i]`. To compute `cuts[i]`, we can iterate from `j = 0` to `i-1`. If the substring `s[j:i]` is a palindrome, it means we can potentially make a cut at `j-1`. The number of cuts would then be `cuts[j] + 1`. We want the minimum over all possible `j`. A key optimization is to pre-compute all possible palindromic substrings. We can use a 2D DP table, `isPalindrome[i][j]`, which is true if `s[i:j+1]` is a palindrome. This avoids checking for palindromes repeatedly inside our main DP loop, improving the time complexity.",
                    "code": {
                        "python": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        # isPalindrome[i][j] is True if s[i:j+1] is a palindrome\n        isPalindrome = [[False] * n for _ in range(n)]\n        for i in range(n):\n            isPalindrome[i][i] = True\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if length == 2:\n                    isPalindrome[i][j] = (s[i] == s[j])\n                else:\n                    isPalindrome[i][j] = (s[i] == s[j] and isPalindrome[i+1][j-1])\n\n        # cuts[i] is the minimum cuts for s[:i+1]\n        cuts = [i for i in range(n)]\n        for i in range(1, n):\n            if isPalindrome[0][i]:\n                cuts[i] = 0\n            else:\n                for j in range(i):\n                    if isPalindrome[j+1][i]:\n                        cuts[i] = min(cuts[i], cuts[j] + 1)\n        return cuts[n-1]"
                    }
                }
            },
            {
                "id": 123,
                "title": "Best Time to Buy and Sell Stock III",
                "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/"
                },
                "youtube_id": "pTQB9wbIpfU",
                "hints": [
                    "You can complete at most two transactions.",
                    "This can be modeled with states. You need to track the maximum profit after: your first buy, your first sell, your second buy, and your second sell."
                ],
                "solution": {
                    "explanation": "This problem can be solved by tracking the maximum profit at each of four state transitions. We iterate through the prices and maintain four variables: `buy1` (max profit after one buy), `sell1` (max profit after one buy and one sell), `buy2` (max profit after a second buy), and `sell2` (max profit after a second buy and second sell). For each price `p`: \n1. `buy1` is the max of its old value and `-p` (the cost of the first buy). \n2. `sell1` is the max of its old value and `buy1 + p` (selling the first stock). \n3. `buy2` is the max of its old value and `sell1 - p` (using profits from the first sale to buy a second stock). \n4. `sell2` is the max of its old value and `buy2 + p` (selling the second stock). \nBy iterating through the prices and updating these four states, `sell2` will hold the maximum profit after at most two transactions.",
                    "code": {
                        "python": "class Solution:\n    def maxProfit(self, prices: list[int]) -> int:\n        buy1, sell1 = float('-inf'), 0\n        buy2, sell2 = float('-inf'), 0\n\n        for price in prices:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        \n        return sell2"
                    }
                }
            },
            {
                "id": 188,
                "title": "Best Time to Buy and Sell Stock IV",
                "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/"
                },
                "youtube_id": "oDhu5uGq_ic",
                "hints": [
                    "This is a generalization of the previous 'Best Time to Buy and Sell Stock' problems.",
                    "Use dynamic programming. Let `dp[i][j]` be the maximum profit on day `j` with at most `i` transactions. This can be optimized to 1D DP arrays for 'buy' and 'sell' states."
                ],
                "solution": {
                    "explanation": "This problem generalizes the previous stock problems to `k` transactions. We can use dynamic programming. First, there's a quick optimization: if `k` is greater than or equal to half the number of days, we can make as many transactions as we want. In this case, we can simply sum up all positive price differences (`prices[i] - prices[i-1]`). For the general case, we use two arrays, `buy` and `sell`, both of size `k+1`. `buy[i]` will store the maximum profit after `i` buys, and `sell[i]` will be the max profit after `i` sells. We iterate through each `price`. For each `i` from 1 to `k`, we update `buy[i]` (max of its old value and `sell[i-1] - price`) and `sell[i]` (max of its old value and `buy[i] + price`). After iterating through all prices, `sell[k]` will contain the maximum profit with at most `k` transactions.",
                    "code": {
                        "python": "class Solution:\n    def maxProfit(self, k: int, prices: list[int]) -> int:\n        n = len(prices)\n        if n < 2:\n            return 0\n\n        # Optimization for unlimited transactions\n        if k >= n // 2:\n            max_profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    max_profit += prices[i] - prices[i-1]\n            return max_profit\n\n        buy = [-float('inf')] * (k + 1)\n        sell = [0] * (k + 1)\n\n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i-1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n\n        return sell[k]"
                    }
                }
            },
            {
                "id": 688,
                "title": "Knight Probability in Chessboard",
                "leetcode_url": "https://leetcode.com/problems/knight-probability-in-chessboard/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/knight-probability-in-chessboard/solutions/113856/9-lines-python-dp-solution/"
                },
                "youtube_id": "54n_yA2H7qI"
            },
            {
                "id": 879,
                "title": "Profitable Schemes",
                "leetcode_url": "https://leetcode.com/problems/profitable-schemes/",
                "solution_link": {
                    "text": "LeetCode Discussion Solution",
                    "url": "https://leetcode.com/problems/profitable-schemes/solutions/159805/c-java-python-dp/"
                },
                "youtube_id": "T0t_c2_2jTU"
            },
            {
                "id": 329,
                "title": "Longest Increasing Path in a Matrix",
                "leetcode_url": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/longest-increasing-path-in-a-matrix"
                },
                "youtube_id": "uG_MtaCJIrM"
            }
        ],
        "Greedy": [
            {
                "id": 55,
                "title": "Jump Game",
                "leetcode_url": "https://leetcode.com/problems/jump-game/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/jump-game"
                },
                "youtube_id": "Yan0cv2cLy8",
                "hints": [
                    "This can be solved with a greedy approach.",
                    "Work backwards from the last index. Keep track of the 'goal' position. If you can reach the current 'goal' from your current position, then your current position becomes the new 'goal'."
                ],
                "solution": {
                    "explanation": "A greedy solution is very efficient for this problem. We can think about it by working backwards from the end. We initialize a `goal` post at the last index of the array. We then iterate from the second-to-last index backwards to the start. At each position `i`, we check if we can reach the current `goal` from this position. The condition for this is `i + nums[i] >= goal`. If we can reach the `goal`, it means this current position `i` is a 'good' position, and we can update our `goal` to be this new position `i`. We continue this process. If, after checking all positions, our `goal` has been updated all the way to index 0, it means the start is a 'good' position and we can reach the end. So, the final answer is `True` if `goal == 0`.",
                    "code": {
                        "python": "class Solution:\n    def canJump(self, nums: list[int]) -> bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0"
                    }
                }
            },
            {
                "id": 45,
                "title": "Jump Game II",
                "leetcode_url": "https://leetcode.com/problems/jump-game-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/jump-game-ii"
                },
                "youtube_id": "dJ7sWiBGzGI",
                "hints": [
                    "This is a greedy problem that can be solved using a technique similar to Breadth-First Search (BFS).",
                    "Think in terms of 'levels'. Level 0 is the start. Level 1 is all the indices you can reach from the start. Level 2 is all indices you can reach from Level 1, and so on. The answer is the number of levels needed to reach the end."
                ],
                "solution": {
                    "explanation": "We can solve this with a greedy approach that is conceptually similar to a BFS. We maintain two pointers, `l` and `r`, which represent the boundaries of the current 'level' of reachable indices. Initially, both are at index 0. We also keep a count of `jumps`. In a loop, we calculate the farthest reachable index `farthest` from the current level `[l, r]`. This is done by iterating from `l` to `r` and finding `max(i + nums[i])`. After scanning the current level, we increment our `jumps` count. The new level's boundaries then become `l = r + 1` and `r = farthest`. We repeat this process. The loop terminates when our right boundary `r` has reached or surpassed the last index of the array. The value of `jumps` at this point is our answer.",
                    "code": {
                        "python": "class Solution:\n    def jump(self, nums: list[int]) -> int:\n        res = 0\n        l = r = 0\n\n        while r < len(nums) - 1:\n            farthest = 0\n            for i in range(l, r + 1):\n                farthest = max(farthest, i + nums[i])\n            l = r + 1\n            r = farthest\n            res += 1\n        return res"
                    }
                }
            },
            {
                "id": 53,
                "title": "Maximum Subarray",
                "leetcode_url": "https://leetcode.com/problems/maximum-subarray/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/maximum-subarray"
                },
                "youtube_id": "5PAs-5L63_k",
                "hints": [
                    "This is a classic problem that can be solved with Kadane's Algorithm.",
                    "Iterate through the array, keeping track of the `current_sum` of the subarray ending at the current position. If `current_sum` ever becomes negative, reset it to zero."
                ],
                "solution": {
                    "explanation": "Kadane's Algorithm provides a linear-time solution. We iterate through the array while maintaining two variables: `maxSub`, which stores the maximum subarray sum found so far, and `curSum`, which stores the sum of the current subarray we are considering. For each number in the array, we add it to `curSum`. We then update `maxSub` with the maximum of its current value and `curSum`. The crucial step is: if `curSum` becomes negative, it means the current subarray is a burden and will not contribute positively to any future subarray. Therefore, we reset `curSum` to 0 and start a new subarray from the next element. This greedy approach ensures we find the maximum possible sum.",
                    "code": {
                        "python": "class Solution:\n    def maxSubArray(self, nums: list[int]) -> int:\n        maxSub = nums[0]\n        curSum = 0\n        \n        for n in nums:\n            if curSum < 0:\n                curSum = 0\n            curSum += n\n            maxSub = max(maxSub, curSum)\n        return maxSub"
                    }
                }
            },
            {
                "id": 871,
                "title": "Minimum Number of Refueling Stops",
                "leetcode_url": "https://leetcode.com/problems/minimum-number-of-refueling-stops/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/minimum-number-of-refueling-stops"
                },
                "youtube_id": "OpC1__pT0fg"
            },
            {
                "id": 134,
                "title": "Gas Station",
                "leetcode_url": "https://leetcode.com/problems/gas-station/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/gas-station"
                },
                "youtube_id": "lJwbPZGo05A",
                "hints": [
                    "First, check if a solution is possible at all. A solution exists only if the total amount of gas is greater than or equal to the total cost to travel.",
                    "If a solution exists, it is unique. You can find the starting station in a single pass. Keep track of the current tank level. If it ever becomes negative, it means you can't reach the next station, so the starting point must be after the current station."
                ],
                "solution": {
                    "explanation": "This problem can be solved with a greedy approach in a single pass. First, a crucial observation: if the total gas available is less than the total cost to travel around the circuit, no solution is possible. We can check this by summing up all `gas[i] - cost[i]`. If this total sum is negative, we return -1. If a solution does exist, we can find the starting point in the same pass. We maintain a `total` sum (for the check above) and a `tank` variable representing the current gas in our tank. We also have a `start` index, initialized to 0. We iterate through the stations. At each station `i`, we add `gas[i] - cost[i]` to our `tank`. If `tank` ever becomes negative, it means we cannot reach station `i+1` from our current `start`. Therefore, the starting station must be at least `i+1`. We reset our `tank` to 0 and update `start = i + 1`. If we complete the loop, the `start` index we have is the correct answer.",
                    "code": {
                        "python": "class Solution:\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n        \n        total = 0\n        start = 0\n        for i in range(len(gas)):\n            total += (gas[i] - cost[i])\n\n            if total < 0:\n                total = 0\n                start = i + 1\n        return start"
                    }
                }
            },
            {
                "id": 57,
                "title": "Insert Interval",
                "leetcode_url": "https://leetcode.com/problems/insert-interval/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/insert-interval"
                },
                "youtube_id": "A8NUOmlwOlM",
                "hints": [
                    "The initial list of intervals is sorted and non-overlapping.",
                    "Iterate through the intervals and categorize them into three groups: those that come completely before the new interval, those that overlap with it, and those that come completely after."
                ],
                "solution": {
                    "explanation": "We can solve this by iterating through the existing intervals and building a new result list. We handle three cases. First, we add all intervals that end before our `newInterval` starts; these do not overlap and come first. Second, we handle the overlapping intervals. We iterate through all intervals that overlap with `newInterval`. As we do, we continuously merge them with `newInterval` by updating the start of `newInterval` to be the minimum of the starts, and the end to be the maximum of the ends. After this loop, `newInterval` will have become a single, large merged interval. We add this merged interval to our result. Finally, we add all the remaining intervals, which are the ones that start after our merged interval ends. These also do not overlap and come last.",
                    "code": {
                        "python": "class Solution:\n    def insert(self, intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        \n        res.append(newInterval)\n        return res"
                    }
                }
            },
            {
                "id": 56,
                "title": "Merge Intervals",
                "leetcode_url": "https://leetcode.com/problems/merge-intervals/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/merge-intervals"
                },
                "youtube_id": "44H3cEC2fFM",
                "hints": [
                    "First, sort the intervals based on their start times.",
                    "Iterate through the sorted intervals and maintain a `merged` list. If the current interval overlaps with the last interval in `merged`, merge them. Otherwise, append the current interval to `merged`."
                ],
                "solution": {
                    "explanation": "To merge overlapping intervals, we first need to sort them based on their start times. This ensures that we can process them in a sequential order. We initialize our `output` list with the first interval. Then, we iterate through the rest of the sorted intervals. For each `current_interval`, we compare it with the `last_interval` in our `output` list. If the start of the `current_interval` is less than or equal to the end of the `last_interval`, they overlap. We merge them by updating the end of the `last_interval` to be the maximum of the two intervals' ends. If they don't overlap, we simply append the `current_interval` to our `output` list. This process continues until all intervals have been considered.",
                    "code": {
                        "python": "class Solution:\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        intervals.sort(key = lambda i : i[0])\n        output = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output"
                    }
                }
            },
            {
                "id": 435,
                "title": "Non-overlapping Intervals",
                "leetcode_url": "https://leetcode.com/problems/non-overlapping-intervals/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/non-overlapping-intervals"
                },
                "youtube_id": "nONCGxWoUfM",
                "hints": [
                    "This is a greedy problem.",
                    "Sort the intervals by their end times. Then, iterate through the sorted intervals, keeping track of the end time of the last interval you kept. If the current interval doesn't overlap with the last one you kept, you can keep it too."
                ],
                "solution": {
                    "explanation": "This problem can be solved with a greedy approach. The goal is to maximize the number of non-overlapping intervals, which is equivalent to minimizing the number of removals. The key greedy insight is to always keep the interval that finishes earliest. So, we first sort the intervals based on their end times. We initialize our count of removals to 0 and keep track of the end time of the last valid interval we've chosen, `prevEnd`. We iterate through the sorted intervals. For each interval, we check if its start time is greater than or equal to `prevEnd`. If it is, it means this interval does not overlap with the last one we kept, so we can keep it and update `prevEnd` to be this interval's end time. If it's not (i.e., it overlaps), we must remove it, so we increment our removal count.",
                    "code": {
                        "python": "class Solution:\n    def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n        intervals.sort()\n        \n        res = 0\n        prevEnd = intervals[0][1]\n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res"
                    }
                }
            },
            {
                "id": 763,
                "title": "Partition Labels",
                "leetcode_url": "https://leetcode.com/problems/partition-labels/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/partition-labels"
                },
                "youtube_id": "B7m8UmZE-4k",
                "hints": [
                    "For each character, you need to know the index of its last occurrence in the string.",
                    "Iterate through the string, keeping track of the 'end' of the current partition. The 'end' is the furthest last occurrence of any character seen so far in the partition."
                ],
                "solution": {
                    "explanation": "This is a greedy problem. First, we need to know the last position of every character in the string. We can pre-process this into a hash map. Then, we iterate through the string with a pointer `i`. We maintain two other variables: `size` of the current partition and `end`, the furthest last-occurrence index we've seen in the current partition. For each character `s[i]`, we update `end = max(end, last_occurrence[s[i]])`. This greedily extends the current partition to include the last occurrence of every character within it. We increment `size`. When our main pointer `i` reaches the `end` of the current partition, it means we have found the smallest possible valid partition. We add its `size` to our result list and reset `size` to 0 to start the next partition.",
                    "code": {
                        "python": "class Solution:\n    def partitionLabels(self, s: str) -> list[int]:\n        lastIndex = {} # char -> last index\n        for i, c in enumerate(s):\n            lastIndex[c] = i\n        \n        res = []\n        size, end = 0, 0\n        for i, c in enumerate(s):\n            size += 1\n            end = max(end, lastIndex[c])\n\n            if i == end:\n                res.append(size)\n                size = 0\n        return res"
                    }
                }
            },
            {
                "id": 678,
                "title": "Valid Parenthesis String",
                "leetcode_url": "https://leetcode.com/problems/valid-parenthesis-string/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/valid-parenthesis-string"
                },
                "youtube_id": "QhPdNS143fE"
            }
        ],
        "Intervals": [
            {
                "id": 57,
                "title": "Insert Interval",
                "leetcode_url": "https://leetcode.com/problems/insert-interval/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/insert-interval"
                },
                "youtube_id": "A8NUOmlwOlM",
                "hints": [
                    "The initial list of intervals is sorted and non-overlapping.",
                    "Iterate through the intervals and categorize them into three groups: those that come completely before the new interval, those that overlap with it, and those that come completely after."
                ],
                "solution": {
                    "explanation": "We can solve this by iterating through the existing intervals and building a new result list. We handle three cases. First, we add all intervals that end before our `newInterval` starts; these do not overlap and come first. Second, we handle the overlapping intervals. We iterate through all intervals that overlap with `newInterval`. As we do, we continuously merge them with `newInterval` by updating the start of `newInterval` to be the minimum of the starts, and the end to be the maximum of the ends. After this loop, `newInterval` will have become a single, large merged interval. We add this merged interval to our result. Finally, we add all the remaining intervals, which are the ones that start after our merged interval ends. These also do not overlap and come last.",
                    "code": {
                        "python": "class Solution:\n    def insert(self, intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        \n        res.append(newInterval)\n        return res"
                    }
                }
            },
            {
                "id": 56,
                "title": "Merge Intervals",
                "leetcode_url": "https://leetcode.com/problems/merge-intervals/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/merge-intervals"
                },
                "youtube_id": "44H3cEC2fFM",
                "hints": [
                    "First, sort the intervals based on their start times.",
                    "Iterate through the sorted intervals and maintain a `merged` list. If the current interval overlaps with the last interval in `merged`, merge them. Otherwise, append the current interval to `merged`."
                ],
                "solution": {
                    "explanation": "To merge overlapping intervals, we first need to sort them based on their start times. This ensures that we can process them in a sequential order. We initialize our `output` list with the first interval. Then, we iterate through the rest of the sorted intervals. For each `current_interval`, we compare it with the `last_interval` in our `output` list. If the start of the `current_interval` is less than or equal to the end of the `last_interval`, they overlap. We merge them by updating the end of the `last_interval` to be the maximum of the two intervals' ends. If they don't overlap, we simply append the `current_interval` to our `output` list. This process continues until all intervals have been considered.",
                    "code": {
                        "python": "class Solution:\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        intervals.sort(key = lambda i : i[0])\n        output = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output"
                    }
                }
            },
            {
                "id": 435,
                "title": "Non-overlapping Intervals",
                "leetcode_url": "https://leetcode.com/problems/non-overlapping-intervals/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/non-overlapping-intervals"
                },
                "youtube_id": "nONCGxWoUfM",
                "hints": [
                    "This is a greedy problem.",
                    "Sort the intervals by their end times. Then, iterate through the sorted intervals, keeping track of the end time of the last interval you kept. If the current interval doesn't overlap with the last one you kept, you can keep it too."
                ],
                "solution": {
                    "explanation": "This problem can be solved with a greedy approach. The goal is to maximize the number of non-overlapping intervals, which is equivalent to minimizing the number of removals. The key greedy insight is to always keep the interval that finishes earliest. So, we first sort the intervals based on their end times. We initialize our count of removals to 0 and keep track of the end time of the last valid interval we've chosen, `prevEnd`. We iterate through the sorted intervals. For each interval, we check if its start time is greater than or equal to `prevEnd`. If it is, it means this interval does not overlap with the last one we kept, so we can keep it and update `prevEnd` to be this interval's end time. If it's not (i.e., it overlaps), we must remove it, so we increment our removal count.",
                    "code": {
                        "python": "class Solution:\n    def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n        intervals.sort()\n        \n        res = 0\n        prevEnd = intervals[0][1]\n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res"
                    }
                }
            },
            {
                "id": 252,
                "title": "Meeting Rooms",
                "leetcode_url": "https://leetcode.com/problems/meeting-rooms/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/meeting-rooms"
                },
                "youtube_id": "i2252q3wBqk",
                "hints": [
                    "To check if any meetings overlap, what is the first step you should take?",
                    "Sort the intervals based on their start times. Then, iterate through the sorted intervals and check if the start time of the current meeting is before the end time of the previous meeting."
                ],
                "solution": {
                    "explanation": "The problem asks if a person can attend all meetings, which means we need to check for any overlaps. A simple and effective approach is to first sort the intervals based on their start times. After sorting, we can just iterate through the intervals from the second one and compare each interval with the one that came before it. If the start time of the current meeting `intervals[i]` is less than the end time of the previous meeting `intervals[i-1]`, it means there is an overlap, and the person cannot attend all meetings. In this case, we can immediately return `False`. If we finish iterating through all the intervals without finding any such overlaps, it means all meetings are compatible, and we can return `True`.",
                    "code": {
                        "python": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution:\n    def canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n        intervals.sort(key = lambda i: i[0])\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i-1]\n            i2 = intervals[i]\n\n            if i1[1] > i2[0]:\n                return False\n        return True"
                    }
                }
            },
            {
                "id": 253,
                "title": "Meeting Rooms II",
                "leetcode_url": "https://leetcode.com/problems/meeting-rooms-ii/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/meeting-rooms-ii"
                },
                "youtube_id": "FdzJmTCVyJU",
                "hints": [
                    "Think about the events happening in chronological order. An event is either a meeting start time or a meeting end time.",
                    "Separate the start times and end times into two sorted lists. Use two pointers to iterate through them. If the next event is a start time, you need a room. If it's an end time, you free up a room."
                ],
                "solution": {
                    "explanation": "This problem can be solved by tracking the number of rooms needed at any given time. A clever way to do this is to separate all the start times and end times into two separate arrays and then sort them. We then use two pointers, one for the start times (`s`) and one for the end times (`e`). We iterate as long as our start time pointer is within bounds. In each iteration, we look at the current start time `start[s]` and end time `end[e]`. If `start[s]` is less than `end[e]`, it means a new meeting is starting before another one has finished, so we need an additional room. We increment our room count and advance the `s` pointer. If `start[s]` is not less than `end[e]`, it means a meeting has finished, freeing up a room, so we can decrement our room count and advance the `e` pointer. We keep track of the maximum number of rooms needed throughout this process.",
                    "code": {
                        "python": "import heapq\n\nclass Solution:\n    def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n        start = sorted([i[0] for i in intervals])\n        end = sorted([i[1] for i in intervals])\n        res, count = 0, 0\n        s, e = 0, 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                s += 1\n                count += 1\n            else:\n                e += 1\n                count -= 1\n            res = max(res, count)\n        return res"
                    }
                }
            }
        ],
        "Math & Geometry": [
            {
                "id": 202,
                "title": "Happy Number",
                "leetcode_url": "https://leetcode.com/problems/happy-number/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/happy-number"
                },
                "youtube_id": "ljz851i3vSs",
                "hints": [
                    "The process of replacing a number with the sum of the squares of its digits can either eventually reach 1, or it will enter a cycle.",
                    "You can detect a cycle by using a hash set to store the numbers you have already seen."
                ],
                "solution": {
                    "explanation": "The key to this problem is detecting a cycle. If the process of summing the squares of digits goes on indefinitely without reaching 1, it must eventually repeat a number, at which point it has entered a cycle. We can detect this using a hash set. We start with the given number `n`. In a loop, we calculate the sum of the squares of its digits to get the next number. Before we repeat the process, we check if this new number is already in our hash set. If it is, we've found a cycle, and the number is not happy, so we return `False`. If not, we add the new number to the set and continue. The loop terminates and we return `True` if the number becomes 1.",
                    "code": {
                        "python": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        visit = set()\n        while n not in visit:\n            visit.add(n)\n            n = self.sumOfSquares(n)\n            if n == 1:\n                return True\n        return False\n\n    def sumOfSquares(self, n: int) -> int:\n        output = 0\n        while n:\n            digit = n % 10\n            digit = digit ** 2\n            output += digit\n            n = n // 10\n        return output"
                    }
                }
            },
            {
                "id": 69,
                "title": "Sqrt(x)",
                "leetcode_url": "https://leetcode.com/problems/sqrtx/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/sqrtx"
                },
                "youtube_id": "zd2_i-g_J2s"
            },
            {
                "id": 50,
                "title": "Pow(x, n)",
                "leetcode_url": "https://leetcode.com/problems/powx-n/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/powx-n"
                },
                "youtube_id": "g9YQyYi4IQQ",
                "hints": [
                    "A naive solution of multiplying `x` by itself `n` times will be too slow.",
                    "Use the 'exponentiation by squaring' method. `x^n` can be calculated as `(x^2)^(n/2)`. This suggests a recursive solution."
                ],
                "solution": {
                    "explanation": "This can be solved efficiently using exponentiation by squaring, which has a logarithmic time complexity. The core idea is that `x^n` is `(x * x)^(n/2)`. We can implement this recursively. The base case is when `n` is 0, in which case the result is 1. In the recursive step, we calculate `res = myPow(x, n // 2)`. The result for `n` is then `res * res`. If `n` is odd, we have an extra factor of `x` to multiply, so the result is `x * res * res`. We also need to handle the case where `n` is negative; we can do this by calculating `myPow(1/x, -n)`.",
                    "code": {
                        "python": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0: return 0\n            if n == 0: return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n        \n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 / res"
                    }
                }
            },
            {
                "id": 66,
                "title": "Plus One",
                "leetcode_url": "https://leetcode.com/problems/plus-one/",
                "solution_link": {
                    "text": "ProgramCreek Solution",
                    "url": "https://www.programcreek.com/2014/05/leetcode-plus-one-java/"
                },
                "youtube_id": "jIaU2D2o_cM",
                "hints": [
                    "You need to simulate adding one to a number represented by an array of digits.",
                    "Iterate through the digits from right to left. Handle the 'carry' operation."
                ],
                "solution": {
                    "explanation": "We can solve this by simulating the addition process, starting from the least significant digit (the rightmost one). We iterate through the digits array from right to left. In each position, we add one. If the result is less than 10, we can simply update the digit and return the array, as no further carry is needed. If the digit becomes 10, we set it to 0 and continue the loop, effectively carrying a '1' to the next digit on the left. If we finish the loop and the leftmost digit was also turned to 0, it means we have a carry that needs a new digit place (e.g., 99 + 1 = 100). In this case, we insert a '1' at the beginning of the array.",
                    "code": {
                        "python": "class Solution:\n    def plusOne(self, digits: list[int]) -> list[int]:\n        n = len(digits)\n        \n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n            \n        # If we are here, it means all digits were 9s\n        new_number = [0] * (n + 1)\n        new_number[0] = 1\n        return new_number"
                    }
                }
            },
            {
                "id": 43,
                "title": "Multiply Strings",
                "leetcode_url": "https://leetcode.com/problems/multiply-strings/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/multiply-strings"
                },
                "youtube_id": "1HPIH2yeC5w",
                "hints": [
                    "You cannot use built-in big integer libraries or convert the inputs to integers directly.",
                    "Simulate the grade-school multiplication algorithm that you learned on paper."
                ],
                "solution": {
                    "explanation": "This problem requires simulating manual multiplication. We can create a result array `res` of size `len(num1) + len(num2)`. We then iterate through `num1` and `num2` from right to left. For each pair of digits `d1` and `d2`, we multiply them and add the result to the appropriate position in our `res` array. The product `d1 * d2` will affect two positions in the result: `res[i+j+1]` (the 'ones' place) and `res[i+j]` (the 'tens' place, or carry). We must handle the carry-over from `res[i+j+1]` to `res[i+j]`. After filling the `res` array, it may have leading zeros, so we need to process it to form the final string representation of the number.",
                    "code": {
                        "python": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if \"0\" in [num1, num2]:\n            return \"0\"\n        \n        res = [0] * (len(num1) + len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 + i2] += digit\n                res[i1 + i2 + 1] += (res[i1 + i2] // 10)\n                res[i1 + i2] = res[i1 + i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg < len(res) and res[beg] == 0:\n            beg += 1\n        \n        return \"\".join(map(str, res[beg:]))"
                    }
                }
            },
            {
                "id": 73,
                "title": "Set Matrix Zeroes",
                "leetcode_url": "https://leetcode.com/problems/set-matrix-zeroes/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/set-matrix-zeroes"
                },
                "youtube_id": "T41rL0L3Pnw",
                "hints": [
                    "A naive solution would be to use O(m+n) extra space to record the rows and columns that need to be zeroed out.",
                    "To achieve O(1) space, you can use the first row and first column of the matrix itself as markers."
                ],
                "solution": {
                    "explanation": "To solve this in-place with O(1) extra space, we can use the first row and first column of the matrix as storage to mark which rows and columns need to be zeroed out. We first iterate through the matrix to determine if the original first row or first column themselves contain a zero, and we store this information in boolean variables. Then, we iterate through the rest of the matrix (from `[1,1]` onwards). If we find a `matrix[r][c] == 0`, we mark its corresponding position in the first row and first column by setting `matrix[0][c] = 0` and `matrix[r][0] = 0`. After this marking pass, we iterate through the matrix again (from `[1,1]` onwards) and set `matrix[r][c]` to zero if its marker in the first row or first column is zero. Finally, based on our initial boolean variables, we zero out the original first row and first column if needed.",
                    "code": {
                        "python": "class Solution:\n    def setZeroes(self, matrix: list[list[int]]) -> None:\n        # O(1) space\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        # determine which rows/cols need to be zero\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r > 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n        \n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0"
                    }
                }
            },
            {
                "id": 54,
                "title": "Spiral Matrix",
                "leetcode_url": "https://leetcode.com/problems/spiral-matrix/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/spiral-matrix"
                },
                "youtube_id": "BJ_5-Lh8kpk",
                "hints": [
                    "Maintain four pointers: `left`, `right`, `top`, and `bottom`, representing the boundaries of the current layer of the matrix.",
                    "In a loop, traverse the top row from left to right, then the right column from top to bottom, then the bottom row from right to left, and finally the left column from bottom to top. After each traversal, shrink the corresponding boundary."
                ],
                "solution": {
                    "explanation": "We can solve this by simulating the spiral traversal layer by layer. We use four pointers to define the boundaries of the current layer: `left`, `right`, `top`, and `bottom`. We loop as long as `left <= right` and `top <= bottom`. In each iteration of the loop, we perform four passes: 1. Traverse Right: We go from `left` to `right` along the `top` row, adding each element to our result. After this, we increment `top`. 2. Traverse Down: We go from `top` to `bottom` along the `right` column. Then, we decrement `right`. 3. Traverse Left: We go from `right` to `left` along the `bottom` row. Then, we decrement `bottom`. 4. Traverse Up: We go from `bottom` to `top` along the `left` column. Then, we increment `left`. We must include checks to ensure our boundaries haven't crossed after shrinking them, to handle non-square matrices correctly.",
                    "code": {
                        "python": "class Solution:\n    def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        while left < right and top < bottom:\n            # get every i in the top row\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n\n            # get every i in the right col\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n\n            if not (left < right and top < bottom):\n                break\n\n            # get every i in the bottom row\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n\n            # get every i in the left col\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n        return res"
                    }
                }
            },
            {
                "id": 48,
                "title": "Rotate Image",
                "leetcode_url": "https://leetcode.com/problems/rotate-image/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/rotate-image"
                },
                "youtube_id": "fMSJSS7eO1w",
                "hints": [
                    "You must do this in-place.",
                    "A 90-degree clockwise rotation is equivalent to first transposing the matrix and then reversing each row."
                ],
                "solution": {
                    "explanation": "Rotating an image 90 degrees clockwise in-place can be achieved with a two-step process. The first step is to transpose the matrix. Transposing means swapping the element at `matrix[i][j]` with the element at `matrix[j][i]`. We can do this with a nested loop, iterating through the upper or lower triangle of the matrix to perform the swaps. The second step is to reverse each row of the transposed matrix. We can iterate through each row and use a two-pointer approach (left and right pointers moving towards the center) to reverse the elements in that row. Performing these two operations in sequence results in a 90-degree clockwise rotation.",
                    "code": {
                        "python": "class Solution:\n    def rotate(self, matrix: list[list[int]]) -> None:\n        l, r = 0, len(matrix) - 1\n\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                # save the topleft\n                topLeft = matrix[top][l + i]\n\n                # move bottom left into top left\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                # move bottom right into bottom left\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                # move top right into bottom right\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                # move top left into top right\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1"
                    }
                }
            },
            {
                "id": 2013,
                "title": "Detect Squares",
                "leetcode_url": "https://leetcode.com/problems/detect-squares/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/detect-squares"
                },
                "youtube_id": "bahebearrDc"
            }
        ],
        "Bit Manipulation": [
            {
                "id": 268,
                "title": "Missing Number",
                "leetcode_url": "https://leetcode.com/problems/missing-number/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/missing-number"
                },
                "youtube_id": "WnPLSRLSANE",
                "hints": [
                    "The sum of numbers from 0 to `n` can be calculated with Gauss' formula. You can find the expected sum and subtract the actual sum of the input array.",
                    "A clever bit manipulation approach uses the XOR operator. `a ^ b ^ b = a`."
                ],
                "solution": {
                    "explanation": "A very elegant solution uses the XOR bitwise operator. The XOR operator has the property that `x ^ x = 0` and `x ^ 0 = x`. We can initialize a result variable to `len(nums)` (which is the value of `n`). Then, we iterate from `i = 0` to `len(nums) - 1`, and in each iteration, we XOR our result with both the index `i` and the value `nums[i]`. The idea is that we are XORing all the numbers in the complete range `[0, n]` and all the numbers in the given array `nums`. Since every number except the missing one appears twice (once as an index, once as a value), their effects will cancel out, leaving only the missing number.",
                    "code": {
                        "python": "class Solution:\n    def missingNumber(self, nums: list[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += (i - nums[i])\n        return res"
                    }
                }
            },
            {
                "id": 191,
                "title": "Number of 1 Bits",
                "leetcode_url": "https://leetcode.com/problems/number-of-1-bits/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/number-of-1-bits"
                },
                "youtube_id": "5Km3utixwZs",
                "hints": [
                    "A simple way is to loop 32 times, check the last bit with the AND operator (`& 1`), and then right shift the number.",
                    "A clever trick to remove the rightmost '1' bit is the operation `n = n & (n - 1)`. The number of times you can do this before `n` becomes 0 is the answer."
                ],
                "solution": {
                    "explanation": "There are several ways to solve this. A straightforward method is to loop through the bits of the number. In each iteration, we can check the least significant bit by performing a bitwise AND with 1 (`n & 1`). If the result is 1, we increment our counter. Then, we right shift the number (`n = n >> 1`) to process the next bit. We repeat this until the number becomes 0. An even more efficient trick is to repeatedly turn off the rightmost '1' bit. The operation `n & (n - 1)` does exactly this. We can put this operation in a loop and count how many times we can perform it before `n` becomes 0. This count is our answer, and this method is often faster as it only iterates as many times as there are '1' bits.",
                    "code": {
                        "python": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= (n - 1)\n            res += 1\n        return res"
                    }
                }
            },
            {
                "id": 338,
                "title": "Counting Bits",
                "leetcode_url": "https://leetcode.com/problems/counting-bits/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/counting-bits"
                },
                "youtube_id": "RyBM56RIWrM",
                "hints": [
                    "You can solve this in O(n) time.",
                    "Notice the pattern: `dp[i]` is related to `dp[i >> 1]` (or `dp[i/2]`). The number of 1s in `i` is the number of 1s in `i/2` plus a potential extra 1 if `i` is odd."
                ],
                "solution": {
                    "explanation": "This can be solved efficiently with dynamic programming by observing a pattern in the bit counts. Let `dp[i]` be the number of '1' bits in the number `i`. We can notice that the number of '1's in `i` is closely related to a previous number. Specifically, `dp[i] = dp[i // 2] + (i % 2)`. This is because right-shifting a number (`i >> 1` or `i // 2`) is like removing its least significant bit. So, the count for `i` is the same as the count for `i // 2`, plus 1 if the bit we removed was a '1' (which is true if `i` is odd). We can build a DP array from 0 to `n`, applying this simple formula at each step to get an O(n) solution.",
                    "code": {
                        "python": "class Solution:\n    def countBits(self, n: int) -> list[int]:\n        dp = [0] * (n + 1)\n        offset = 1\n\n        for i in range(1, n + 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 + dp[i - offset]\n        return dp"
                    }
                }
            },
            {
                "id": 371,
                "title": "Sum of Two Integers",
                "leetcode_url": "https://leetcode.com/problems/sum-of-two-integers/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/sum-of-two-integers"
                },
                "youtube_id": "gV-3O1EEg48",
                "hints": [
                    "You cannot use the `+` or `-` operators. You must use bitwise operators.",
                    "The sum can be broken into two parts: the sum without carrying (which is XOR), and the carry bits (which is AND, left-shifted)."
                ],
                "solution": {
                    "explanation": "This problem requires simulating addition using bitwise operations. Addition can be thought of in two parts: the sum of bits where at least one is 0 (which is the XOR operation), and the carry bits generated when both bits are 1 (which is the AND operation, shifted one position to the left). We can perform this in a loop. In each iteration, we calculate `sum_without_carry = a ^ b` and `carry = (a & b) << 1`. We then update `a` to be the `sum_without_carry` and `b` to be the `carry`. We repeat this loop until the `carry` (`b`) becomes 0. At that point, `a` will hold the final sum. Handling negative numbers in Python requires masking with `0xffffffff` to simulate 32-bit integers.",
                    "code": {
                        "python": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        mask = 0xffffffff\n        \n        while (b & mask) > 0:\n            carry = (a & b) << 1\n            a = a ^ b\n            b = carry\n            \n        return (a & mask) if b > 0 else a"
                    }
                }
            },
            {
                "id": 190,
                "title": "Reverse Bits",
                "leetcode_url": "https://leetcode.com/problems/reverse-bits/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reverse-bits"
                },
                "youtube_id": "UcoN6UjAI64",
                "hints": [
                    "You need to process the input number bit by bit.",
                    "In a loop that runs 32 times, take the last bit of the input number and append it to your result. Then, left shift your result and right shift the input number."
                ],
                "solution": {
                    "explanation": "To reverse the bits, we can process the input number `n` one bit at a time for 32 iterations. We initialize our result `res` to 0. In each iteration, we first left shift our result (`res << 1`) to make space for the next bit. Then, we take the least significant bit of `n` by doing `n & 1`. We add this bit to our result using a bitwise OR. Finally, we right shift `n` (`n >> 1`) to process its next bit in the following iteration. After 32 loops, `res` will hold the bit-reversed integer.",
                    "code": {
                        "python": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n\n        for i in range(32):\n            bit = (n >> i) & 1\n            res = res | (bit << (31 - i))\n        return res"
                    }
                }
            },
            {
                "id": 7,
                "title": "Reverse Integer",
                "leetcode_url": "https://leetcode.com/problems/reverse-integer/",
                "solution_link": {
                    "text": "NeetCode Solution",
                    "url": "https://neetcode.io/solutions/reverse-integer"
                },
                "youtube_id": "HAgLH58IgJQ",
                "hints": [
                    "Think about popping the last digit of the number and pushing it to the back of a new result number.",
                    "You must handle potential overflow. Before you multiply your result by 10 and add the new digit, check if this operation would exceed the 32-bit signed integer limits."
                ],
                "solution": {
                    "explanation": "To reverse an integer, we can repeatedly take the last digit of the input `x` and build up a `result` number. We use the modulo operator (`% 10`) to get the last digit and integer division (`// 10`) to remove it from `x`. In each step, we update our `result` by multiplying it by 10 and adding the new digit. The most important part is handling the 32-bit integer overflow. Before we update the `result`, we must check if `result * 10 + digit` would go outside the range `[-2**31, 2**31 - 1]`. If it would, we must return 0. We also need to correctly handle the sign of the input number.",
                    "code": {
                        "python": "class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2**31\n        MAX = 2**31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10)) \n            x = int(x / 10)\n\n            if (res > MAX // 10 or \n                (res == MAX // 10 and digit > MAX % 10)):\n                return 0\n            if (res < MIN // 10 or \n                (res == MIN // 10 and digit < MIN % 10)):\n                return 0\n            res = (res * 10) + digit\n        \n        return res"
                    }
                }
            }
        ]
    }
}